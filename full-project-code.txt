=== PROJECT STRUCTURE ===
src/App.css
src/App.tsx
src/components/AccountBalancesChart.tsx
src/components/AccountSelectionModal.tsx
src/components/AddAccountModal.tsx
src/components/AddTransactionModal.tsx
src/components/BudgetModal.tsx
src/components/BudgetProgress.tsx
src/components/BudgetSummaryWidget.tsx
src/components/ColorTest.tsx
src/components/ImportDataModal.tsx
src/components/IncomeVsExpensesChart.tsx
src/components/Layout.tsx
src/components/LoadingScreen.tsx
src/components/MnyMappingModal.tsx
src/components/MobileDebug.tsx
src/components/NetWorthTrendChart.tsx
src/components/ReconciliationModal.tsx
src/components/RecurringTransactionModal.tsx
src/components/SpendingByCategoryChart.tsx
src/components/SplitTransactionModal.tsx
src/components/ThemeDebugger.tsx
src/components/TransactionModal.tsx
src/contexts/AppContext.tsx
src/contexts/PreferencesContext.tsx
src/index.css
src/main.tsx
src/pages/Accounts.tsx
src/pages/Analytics.tsx
src/pages/Budget.tsx
src/pages/Dashboard.tsx
src/pages/Goals.tsx
src/pages/Investments.tsx
src/pages/Reconciliation.tsx
src/pages/Reports.tsx
src/pages/Settings.tsx
src/pages/Transactions.tsx
src/types/index.ts
src/utils/formatters.ts
src/utils/generateTestData.ts
src/utils/initializeApp.ts
src/utils/mbfParser.ts
src/utils/mnyParser.ts
src/utils/qifParser.ts
src/vite-env.d.ts

=== PACKAGE.JSON ===
{
  "name": "money-management",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "chart.js": "^4.5.0",
    "lucide-react": "^0.525.0",
    "react": "^19.1.0",
    "react-chartjs-2": "^5.3.0",
    "react-dom": "^19.1.0",
    "react-router-dom": "^7.6.3",
    "recharts": "^3.1.0"
  },
  "devDependencies": {
    "@eslint/js": "^9.30.1",
    "@types/react": "^19.1.8",
    "@types/react-dom": "^19.1.6",
    "@vitejs/plugin-react": "^4.6.0",
    "autoprefixer": "^10.4.17",
    "eslint": "^9.30.1",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.20",
    "globals": "^16.3.0",
    "postcss": "^8.4.35",
    "tailwindcss": "^3.4.1",
    "typescript": "~5.8.3",
    "typescript-eslint": "^8.35.1",
    "vite": "^7.0.4"
  }
}


=== src/App.tsx ===
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { AppProvider } from './contexts/AppContext';
import Layout from './components/Layout';
import Dashboard from './pages/Dashboard';
import Accounts from './pages/Accounts';
import Transactions from './pages/Transactions';
import Reconciliation from './pages/Reconciliation';
import Budgets from './pages/Budget';
import Reports from './pages/Reports';
import Settings from './pages/Settings';

function App() {
  return (
    <AppProvider>
      <Router>
        <Routes>
          <Route path="/" element={<Layout />}>
            <Route index element={<Dashboard />} />
            <Route path="/accounts" element={<Accounts />} />
            <Route path="/transactions" element={<Transactions />} />
            <Route path="/reconciliation" element={<Reconciliation />} />
            <Route path="/budgets" element={<Budgets />} />
            <Route path="/reports" element={<Reports />} />
            <Route path="/settings" element={<Settings />} />
          </Route>
        </Routes>
      </Router>
    </AppProvider>
  );
}

export default App;


=== src/components/AccountBalancesChart.tsx ===
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, Cell } from 'recharts';
import { useApp } from '../contexts/AppContext';

export default function AccountBalancesChart() {
  const { accounts } = useApp();
  
  const data = accounts.map(account => ({
    name: account.name,
    balance: account.balance,
    type: account.type,
  }));

  const getColor = (type: string) => {
    const colors: Record<string, string> = {
      checking: '#0078d4',
      savings: '#34c759',
      credit: '#ff3b30',
      investment: '#af52de',
      loan: '#ff9500',
      other: '#5ac8fa',
    };
    return colors[type] || colors.other;
  };

  const formatCurrency = (value: number) => `£${Math.abs(value).toFixed(0)}`;

  if (data.length === 0) {
    return null;
  }

  return (
    <div className="bg-white p-6 rounded-lg shadow">
      <h3 className="text-lg font-semibold mb-4">Account Balances</h3>
      <ResponsiveContainer width="100%" height={300}>
        <BarChart data={data} layout="horizontal">
          <CartesianGrid strokeDasharray="3 3" />
          <XAxis type="number" tickFormatter={formatCurrency} />
          <YAxis dataKey="name" type="category" width={100} />
          <Tooltip formatter={(value: number) => `£${value.toFixed(2)}`} />
          <Bar dataKey="balance">
            {data.map((entry, index) => (
              <Cell key={`cell-${index}`} fill={getColor(entry.type)} />
            ))}
          </Bar>
        </BarChart>
      </ResponsiveContainer>
    </div>
  );
}


=== src/components/AccountSelectionModal.tsx ===
import { useState } from 'react';
import { Check, AlertCircle, FileText } from 'lucide-react';

interface Account {
  name: string;
  type: string;
  balance: number;
  isPrimary?: boolean;
  transactionCount?: number;
}

interface AccountSelectionModalProps {
  isOpen: boolean;
  accounts: Account[];
  primaryAccountName?: string;
  onConfirm: (selectedAccounts: string[]) => void;
  onCancel: () => void;
}

export default function AccountSelectionModal({ 
  isOpen, 
  accounts, 
  primaryAccountName,
  onConfirm, 
  onCancel 
}: AccountSelectionModalProps) {
  const [selectedAccounts, setSelectedAccounts] = useState<Set<string>>(
    new Set(primaryAccountName ? [primaryAccountName] : [])
  );
  const [importMode, setImportMode] = useState<'single' | 'multiple'>('single');

  const handleAccountToggle = (accountName: string) => {
    const newSelected = new Set(selectedAccounts);
    if (importMode === 'single') {
      // Single mode - only one account can be selected
      newSelected.clear();
      newSelected.add(accountName);
    } else {
      // Multiple mode - toggle selection
      if (newSelected.has(accountName)) {
        newSelected.delete(accountName);
      } else {
        newSelected.add(accountName);
      }
    }
    setSelectedAccounts(newSelected);
  };

  const handleModeChange = (mode: 'single' | 'multiple') => {
    setImportMode(mode);
    if (mode === 'single') {
      // When switching to single mode, keep only the primary account or first selected
      const firstSelected = primaryAccountName || Array.from(selectedAccounts)[0] || accounts[0]?.name;
      setSelectedAccounts(new Set(firstSelected ? [firstSelected] : []));
    }
  };

  const handleConfirm = () => {
    onConfirm(Array.from(selectedAccounts));
  };

  if (!isOpen) return null;

  const formatCurrency = (amount: number) => {
    return new Intl.NumberFormat('en-GB', {
      style: 'currency',
      currency: 'GBP'
    }).format(amount);
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-2xl max-h-[90vh] overflow-y-auto">
        <h2 className="text-xl font-semibold dark:text-white mb-4">Select Accounts to Import</h2>

        <div className="mb-4 bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-4">
          <div className="flex items-start gap-2">
            <AlertCircle className="text-blue-600 dark:text-blue-400 mt-0.5" size={20} />
            <div className="text-sm text-blue-800 dark:text-blue-200">
              <p className="font-semibold mb-1">Multiple accounts detected</p>
              <p>We found {accounts.length} account{accounts.length > 1 ? 's' : ''} in this QIF file. 
                {primaryAccountName && ` "${primaryAccountName}" appears to be the main account.`}</p>
            </div>
          </div>
        </div>

        {/* Import Mode Selection */}
        <div className="mb-6">
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            Import Mode
          </label>
          <div className="grid grid-cols-2 gap-3">
            <button
              onClick={() => handleModeChange('single')}
              className={`px-4 py-2 rounded-lg border-2 transition-colors ${
                importMode === 'single'
                  ? 'border-primary bg-primary/10 text-primary dark:bg-primary/20'
                  : 'border-gray-300 dark:border-gray-600 text-gray-700 dark:text-gray-300'
              }`}
            >
              <div className="font-medium">Single Account</div>
              <div className="text-xs mt-1">Import one account with all its transactions</div>
            </button>
            <button
              onClick={() => handleModeChange('multiple')}
              className={`px-4 py-2 rounded-lg border-2 transition-colors ${
                importMode === 'multiple'
                  ? 'border-primary bg-primary/10 text-primary dark:bg-primary/20'
                  : 'border-gray-300 dark:border-gray-600 text-gray-700 dark:text-gray-300'
              }`}
            >
              <div className="font-medium">Multiple Accounts</div>
              <div className="text-xs mt-1">Set up all accounts (import primary transactions)</div>
            </button>
          </div>
        </div>

        {/* Account List */}
        <div className="mb-6">
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
            Available Accounts
          </label>
          <div className="space-y-2 max-h-64 overflow-y-auto">
            {accounts.map((account) => (
              <div
                key={account.name}
                onClick={() => handleAccountToggle(account.name)}
                className={`p-3 rounded-lg border-2 cursor-pointer transition-colors ${
                  selectedAccounts.has(account.name)
                    ? 'border-primary bg-primary/10 dark:bg-primary/20'
                    : 'border-gray-200 dark:border-gray-700 hover:border-gray-300 dark:hover:border-gray-600'
                }`}
              >
                <div className="flex items-start gap-3">
                  <div className="mt-1">
                    {importMode === 'single' ? (
                      <input
                        type="radio"
                        checked={selectedAccounts.has(account.name)}
                        onChange={() => {}}
                        className="text-primary"
                      />
                    ) : (
                      <input
                        type="checkbox"
                        checked={selectedAccounts.has(account.name)}
                        onChange={() => {}}
                        className="rounded text-primary"
                      />
                    )}
                  </div>
                  <div className="flex-1">
                    <div className="flex items-center gap-2">
                      <h3 className="font-medium text-gray-900 dark:text-white">
                        {account.name}
                      </h3>
                      {account.isPrimary && (
                        <span className="text-xs bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300 px-2 py-0.5 rounded">
                          Primary
                        </span>
                      )}
                    </div>
                    <div className="flex items-center gap-4 mt-1 text-sm text-gray-600 dark:text-gray-400">
                      <span>Type: {account.type}</span>
                      {account.balance !== 0 && (
                        <span>Balance: {formatCurrency(account.balance)}</span>
                      )}
                      {account.transactionCount !== undefined && account.transactionCount > 0 && (
                        <span className="flex items-center gap-1">
                          <FileText size={14} />
                          {account.transactionCount} transactions
                        </span>
                      )}
                    </div>
                  </div>
                </div>
              </div>
            ))}
          </div>
        </div>

        {/* Info Message */}
        {importMode === 'multiple' && (
          <div className="mb-4 text-sm text-gray-600 dark:text-gray-400">
            <p>Note: When importing multiple accounts, only transactions from the primary account will be imported. 
            This helps set up your account structure for future imports.</p>
          </div>
        )}

        {/* Actions */}
        <div className="flex gap-3">
          <button
            onClick={onCancel}
            className="flex-1 px-4 py-2 border border-gray-300 dark:border-gray-600 text-gray-700 dark:text-gray-300 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-700"
          >
            Cancel
          </button>
          <button
            onClick={handleConfirm}
            disabled={selectedAccounts.size === 0}
            className={`flex-1 px-4 py-2 rounded-lg flex items-center justify-center gap-2 ${
              selectedAccounts.size > 0
                ? 'bg-primary text-white hover:bg-secondary'
                : 'bg-gray-300 dark:bg-gray-600 text-gray-500 dark:text-gray-400 cursor-not-allowed'
            }`}
          >
            <Check size={20} />
            Import {selectedAccounts.size} Account{selectedAccounts.size !== 1 ? 's' : ''}
          </button>
        </div>
      </div>
    </div>
  );
}


=== src/components/AddAccountModal.tsx ===
import { useState } from 'react';
import { useApp } from '../contexts/AppContext';
import { X } from 'lucide-react';

interface AddAccountModalProps {
  isOpen: boolean;
  onClose: () => void;
}

export default function AddAccountModal({ isOpen, onClose }: AddAccountModalProps) {
  const { addAccount } = useApp();
  const [name, setName] = useState('');
  const [type, setType] = useState<'checking' | 'savings' | 'credit' | 'loan' | 'investment'>('checking');
  const [balance, setBalance] = useState('');
  const [currency, setCurrency] = useState('GBP');
  const [institution, setInstitution] = useState('');

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    addAccount({
      name,
      type,
      balance: parseFloat(balance) || 0,
      currency,
      institution,
      lastUpdated: new Date(),
    });

    // Reset form
    setName('');
    setType('checking');
    setBalance('');
    setCurrency('GBP');
    setInstitution('');
    onClose();
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-md">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-xl font-semibold dark:text-white">Add New Account</h2>
          <button
            onClick={onClose}
            className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
          >
            <X size={24} />
          </button>
        </div>

        <form onSubmit={handleSubmit}>
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Account Name
              </label>
              <input
                type="text"
                value={name}
                onChange={(e) => setName(e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-primary"
                required
              />
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Account Type
              </label>
              <select
                value={type}
                onChange={(e) => setType(e.target.value as any)}
                className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-primary"
              >
                <option value="checking">Checking</option>
                <option value="savings">Savings</option>
                <option value="credit">Credit Card</option>
                <option value="loan">Loan</option>
                <option value="investment">Investment</option>
              </select>
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Current Balance
              </label>
              <input
                type="number"
                step="0.01"
                value={balance}
                onChange={(e) => setBalance(e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-primary"
                required
              />
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Currency
              </label>
              <select
                value={currency}
                onChange={(e) => setCurrency(e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-primary"
              >
                <option value="GBP">GBP £</option>
                <option value="USD">USD $</option>
                <option value="EUR">EUR €</option>
              </select>
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Institution
              </label>
              <input
                type="text"
                value={institution}
                onChange={(e) => setInstitution(e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-primary"
                placeholder="e.g., Barclays, HSBC"
              />
            </div>
          </div>

          <div className="flex gap-3 mt-6">
            <button
              type="button"
              onClick={onClose}
              className="flex-1 px-4 py-2 border border-gray-300 dark:border-gray-600 text-gray-700 dark:text-gray-300 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-700"
            >
              Cancel
            </button>
            <button
              type="submit"
              className="flex-1 px-4 py-2 bg-primary text-white rounded-lg hover:bg-secondary"
            >
              Add Account
            </button>
          </div>
        </form>
      </div>
    </div>
  );
}


=== src/components/AddTransactionModal.tsx ===
import { useState } from 'react';
import { useApp } from '../contexts/AppContext';
import { X } from 'lucide-react';

interface AddTransactionModalProps {
  isOpen: boolean;
  onClose: () => void;
}

const CATEGORIES = [
  'Food & Dining',
  'Shopping',
  'Transport',
  'Bills',
  'Entertainment',
  'Healthcare',
  'Investment',
  'Salary',
  'Freelance',
  'Other',
];

export default function AddTransactionModal({ isOpen, onClose }: AddTransactionModalProps) {
  const { accounts, addTransaction } = useApp();
  const [description, setDescription] = useState('');
  const [amount, setAmount] = useState('');
  const [type, setType] = useState<'income' | 'expense'>('expense');
  const [category, setCategory] = useState('');
  const [accountId, setAccountId] = useState('');
  const [date, setDate] = useState(new Date().toISOString().split('T')[0]);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!description || !amount || !category || !accountId) return;

    addTransaction({
      description,
      amount: parseFloat(amount),
      type,
      category,
      accountId,
      date: new Date(date),
    });

    // Reset form
    setDescription('');
    setAmount('');
    setType('expense');
    setCategory('');
    setAccountId('');
    setDate(new Date().toISOString().split('T')[0]);
    onClose();
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-md max-h-[90vh] overflow-y-auto">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-xl font-semibold dark:text-white">Add Transaction</h2>
          <button
            onClick={onClose}
            className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
          >
            <X size={24} />
          </button>
        </div>

        <form onSubmit={handleSubmit}>
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Type
              </label>
              <div className="grid grid-cols-2 gap-2">
                <button
                  type="button"
                  onClick={() => setType('income')}
                  className={`px-4 py-2 rounded-lg font-medium transition-colors ${
                    type === 'income'
                      ? 'bg-green-500 text-white'
                      : 'bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300'
                  }`}
                >
                  Income
                </button>
                <button
                  type="button"
                  onClick={() => setType('expense')}
                  className={`px-4 py-2 rounded-lg font-medium transition-colors ${
                    type === 'expense'
                      ? 'bg-red-500 text-white'
                      : 'bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300'
                  }`}
                >
                  Expense
                </button>
              </div>
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Account
              </label>
              <select
                value={accountId}
                onChange={(e) => setAccountId(e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-primary"
                required
              >
                <option value="">Select account</option>
                {accounts.map(account => (
                  <option key={account.id} value={account.id}>
                    {account.name} ({account.type})
                  </option>
                ))}
              </select>
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Description
              </label>
              <input
                type="text"
                value={description}
                onChange={(e) => setDescription(e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-primary"
                placeholder="e.g., Grocery shopping"
                required
              />
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Amount (£)
              </label>
              <input
                type="number"
                step="0.01"
                value={amount}
                onChange={(e) => setAmount(e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-primary"
                placeholder="0.00"
                required
              />
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Category
              </label>
              <select
                value={category}
                onChange={(e) => setCategory(e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-primary"
                required
              >
                <option value="">Select category</option>
                {CATEGORIES.map(cat => (
                  <option key={cat} value={cat}>{cat}</option>
                ))}
              </select>
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Date
              </label>
              <input
                type="date"
                value={date}
                onChange={(e) => setDate(e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-primary"
                required
              />
            </div>
          </div>

          <div className="flex gap-3 mt-6">
            <button
              type="button"
              onClick={onClose}
              className="flex-1 px-4 py-2 border border-gray-300 dark:border-gray-600 text-gray-700 dark:text-gray-300 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-700"
            >
              Cancel
            </button>
            <button
              type="submit"
              className="flex-1 px-4 py-2 bg-primary text-white rounded-lg hover:bg-secondary"
            >
              Add Transaction
            </button>
          </div>
        </form>
      </div>
    </div>
  );
}


=== src/components/BudgetModal.tsx ===
import { useState, useEffect } from 'react';
import { useApp } from '../contexts/AppContext';
import { X } from 'lucide-react';

interface BudgetModalProps {
  isOpen: boolean;
  onClose: () => void;
  budget?: any;
}

export default function BudgetModal({ isOpen, onClose, budget }: BudgetModalProps) {
  const { addBudget, updateBudget } = useApp();
  const [formData, setFormData] = useState({
    category: budget?.category || '',
    amount: budget?.amount || '',
    period: budget?.period || 'monthly' as 'monthly' | 'yearly',
    isActive: budget?.isActive !== false
  });

  useEffect(() => {
    if (budget) {
      setFormData({
        category: budget.category || '',
        amount: budget.amount || '',
        period: budget.period || 'monthly',
        isActive: budget.isActive !== false
      });
    }
  }, [budget]);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    const budgetData = {
      category: formData.category,
      amount: parseFloat(formData.amount),
      period: formData.period,
      isActive: formData.isActive
    };

    if (budget) {
      updateBudget(budget.id, budgetData);
    } else {
      addBudget(budgetData);
    }

    onClose();
    setFormData({ category: '', amount: '', period: 'monthly', isActive: true });
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-md">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-xl font-semibold dark:text-white">
            {budget ? 'Edit Budget' : 'Add Budget'}
          </h2>
          <button
            onClick={onClose}
            className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
          >
            <X size={24} />
          </button>
        </div>

        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Category
            </label>
            <input
              type="text"
              required
              value={formData.category}
              onChange={(e) => setFormData({ ...formData, category: e.target.value })}
              className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
              placeholder="e.g., Groceries, Entertainment"
            />
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Amount
            </label>
            <input
              type="number"
              required
              step="0.01"
              value={formData.amount}
              onChange={(e) => setFormData({ ...formData, amount: e.target.value })}
              className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
              placeholder="0.00"
            />
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Period
            </label>
            <select
              value={formData.period}
              onChange={(e) => setFormData({ ...formData, period: e.target.value as 'monthly' | 'yearly' })}
              className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
            >
              <option value="monthly">Monthly</option>
              <option value="yearly">Yearly</option>
            </select>
          </div>

          <div className="flex items-center gap-2">
            <input
              type="checkbox"
              id="isActive"
              checked={formData.isActive}
              onChange={(e) => setFormData({ ...formData, isActive: e.target.checked })}
              className="rounded border-gray-300 dark:border-gray-600"
            />
            <label htmlFor="isActive" className="text-sm text-gray-700 dark:text-gray-300">
              Budget is active
            </label>
          </div>

          <div className="flex gap-3">
            <button
              type="button"
              onClick={onClose}
              className="flex-1 px-4 py-2 border border-gray-300 dark:border-gray-600 text-gray-700 dark:text-gray-300 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-700"
            >
              Cancel
            </button>
            <button
              type="submit"
              className="flex-1 px-4 py-2 bg-primary text-white rounded-lg hover:bg-secondary"
            >
              {budget ? 'Save Changes' : 'Add Budget'}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
}


=== src/components/BudgetProgress.tsx ===
import { AlertCircle, CheckCircle, XCircle } from 'lucide-react';

interface BudgetProgressProps {
  category: string;
  budgetAmount: number;
  spent: number;
  onEdit?: () => void;
  onDelete?: () => void;
}

export default function BudgetProgress({ 
  category, 
  budgetAmount, 
  spent, 
  onEdit, 
  onDelete 
}: BudgetProgressProps) {
  const percentage = budgetAmount > 0 ? (spent / budgetAmount) * 100 : 0;
  const remaining = budgetAmount - spent;
  
  const getProgressColor = () => {
    if (percentage >= 100) return 'bg-red-500';
    if (percentage >= 80) return 'bg-yellow-500';
    return 'bg-green-500';
  };
  
  const getStatusIcon = () => {
    if (percentage >= 100) return <XCircle className="text-red-500" size={20} />;
    if (percentage >= 80) return <AlertCircle className="text-yellow-500" size={20} />;
    return <CheckCircle className="text-green-500" size={20} />;
  };
  
  const getStatusText = () => {
    if (percentage >= 100) return 'Over budget';
    if (percentage >= 80) return 'Approaching limit';
    return 'On track';
  };

  return (
    <div className="bg-white p-4 rounded-lg shadow">
      <div className="flex justify-between items-start mb-3">
        <div className="flex items-center gap-2">
          <h3 className="font-semibold text-gray-900">{category}</h3>
          {getStatusIcon()}
        </div>
        <div className="flex gap-1">
          {onEdit && (
            <button
              onClick={onEdit}
              className="text-sm text-primary hover:text-secondary px-2 py-1"
            >
              Edit
            </button>
          )}
          {onDelete && (
            <button
              onClick={onDelete}
              className="text-sm text-red-500 hover:text-red-700 px-2 py-1"
            >
              Delete
            </button>
          )}
        </div>
      </div>
      
      <div className="space-y-2">
        <div className="flex justify-between text-sm">
          <span className="text-gray-600">Spent</span>
          <span className="font-medium">£{spent.toFixed(2)} of £{budgetAmount.toFixed(2)}</span>
        </div>
        
        <div className="w-full bg-gray-200 rounded-full h-2">
          <div
            className={`h-2 rounded-full transition-all duration-300 ${getProgressColor()}`}
            style={{ width: `${Math.min(percentage, 100)}%` }}
          />
        </div>
        
        <div className="flex justify-between text-sm">
          <span className={`font-medium ${percentage >= 100 ? 'text-red-600' : 'text-gray-700'}`}>
            {getStatusText()}
          </span>
          <span className={remaining >= 0 ? 'text-green-600' : 'text-red-600'}>
            {remaining >= 0 ? `£${remaining.toFixed(2)} left` : `£${Math.abs(remaining).toFixed(2)} over`}
          </span>
        </div>
      </div>
    </div>
  );
}


=== src/components/BudgetSummaryWidget.tsx ===
import { useApp } from '../contexts/AppContext';
import { Target, AlertCircle } from 'lucide-react';
import { Link } from 'react-router-dom';

export default function BudgetSummaryWidget() {
  const { budgets, transactions } = useApp();
  
  // Calculate current month's spending
  const currentMonth = new Date().getMonth();
  const currentYear = new Date().getFullYear();
  
  const monthlySpending = transactions
    .filter(t => {
      const date = new Date(t.date);
      return t.type === 'expense' && 
             date.getMonth() === currentMonth && 
             date.getFullYear() === currentYear;
    })
    .reduce((acc, t) => {
      const category = t.category || 'Other';
      acc[category] = (acc[category] || 0) + t.amount;
      return acc;
    }, {} as Record<string, number>);

  // Get active budgets
  const activeBudgets = budgets.filter(b => b.isActive && b.period === 'monthly');
  
  // Find budgets that are over 80% spent
  const warningBudgets = activeBudgets.filter(budget => {
    const spent = monthlySpending[budget.category] || 0;
    const percentage = (spent / budget.amount) * 100;
    return percentage >= 80;
  });

  if (activeBudgets.length === 0) {
    return (
      <div className="bg-white p-6 rounded-lg shadow">
        <h3 className="text-lg font-semibold mb-4 flex items-center gap-2">
          <Target size={20} />
          Budget Overview
        </h3>
        <p className="text-gray-500 text-center py-4">
          No budgets set. 
          <Link to="/budget" className="text-primary hover:text-secondary ml-1">
            Set up budgets
          </Link>
        </p>
      </div>
    );
  }

  return (
    <div className="bg-white p-6 rounded-lg shadow">
      <h3 className="text-lg font-semibold mb-4 flex items-center gap-2">
        <Target size={20} />
        Budget Overview
      </h3>
      
      {warningBudgets.length > 0 && (
        <div className="mb-4 p-3 bg-yellow-50 border border-yellow-200 rounded-lg">
          <div className="flex items-start gap-2">
            <AlertCircle className="text-yellow-600 mt-0.5" size={16} />
            <div className="text-sm">
              <p className="font-medium text-yellow-900">
                {warningBudgets.length} budget{warningBudgets.length > 1 ? 's' : ''} need attention
              </p>
              <p className="text-yellow-700">
                {warningBudgets.map(b => b.category).join(', ')}
              </p>
            </div>
          </div>
        </div>
      )}
      
      <div className="space-y-3">
        {activeBudgets.slice(0, 3).map(budget => {
          const spent = monthlySpending[budget.category] || 0;
          const percentage = Math.min((spent / budget.amount) * 100, 100);
          
          return (
            <div key={budget.id}>
              <div className="flex justify-between text-sm mb-1">
                <span className="text-gray-700">{budget.category}</span>
                <span className="text-gray-600">
                  £{spent.toFixed(0)}/£{budget.amount.toFixed(0)}
                </span>
              </div>
              <div className="w-full bg-gray-200 rounded-full h-2">
                <div
                  className={`h-2 rounded-full transition-all ${
                    percentage >= 100 ? 'bg-red-500' :
                    percentage >= 80 ? 'bg-yellow-500' : 'bg-green-500'
                  }`}
                  style={{ width: `${percentage}%` }}
                />
              </div>
            </div>
          );
        })}
      </div>
      
      <Link 
        to="/budget" 
        className="block text-center text-sm text-primary hover:text-secondary mt-4"
      >
        View all budgets →
      </Link>
    </div>
  );
}


=== src/components/ColorTest.tsx ===
export default function ColorTest() {
  return (
    <div className="fixed bottom-20 right-4 bg-white dark:bg-gray-800 p-4 rounded-lg shadow-lg z-50">
      <p className="text-xs font-bold mb-2">Color Test:</p>
      <div className="space-y-2">
        <button className="bg-primary text-white px-3 py-1 rounded text-xs hover:bg-secondary">
          Primary Button
        </button>
        <div className="text-primary text-xs">Primary Text</div>
        <div className="border-2 border-primary px-2 py-1 text-xs">Primary Border</div>
      </div>
    </div>
  );
}


=== src/components/ImportDataModal.tsx ===
import { useState } from 'react';
import { useApp } from '../contexts/AppContext';
import { X, Upload, FileText, AlertCircle, CheckCircle, Info, AlertTriangle } from 'lucide-react';
import { parseMNY, parseMBF, applyMappingToData } from '../utils/mnyParser';
import { parseQIF as enhancedParseQIF } from '../utils/qifParser';
import MnyMappingModal from './MnyMappingModal';

interface ImportDataModalProps {
  isOpen: boolean;
  onClose: () => void;
}

interface ParsedTransaction {
  date: Date;
  amount: number;
  description: string;
  type: 'income' | 'expense';
  category: string;
  payee?: string;
}

interface ParsedAccount {
  name: string;
  type: 'checking' | 'savings' | 'credit' | 'loan' | 'investment';
  balance: number;
}

interface ParsedData {
  accounts: ParsedAccount[];
  transactions: ParsedTransaction[];
  warning?: string;
  rawData?: any[];
  needsMapping?: boolean;
}

export default function ImportDataModal({ isOpen, onClose }: ImportDataModalProps) {
  const { addAccount, addTransaction, accounts } = useApp();
  const [file, setFile] = useState<File | null>(null);
  const [importing, setImporting] = useState(false);
  const [parsing, setParsing] = useState(false);
  const [status, setStatus] = useState<'idle' | 'success' | 'error'>('idle');
  const [message, setMessage] = useState('');
  const [preview, setPreview] = useState<ParsedData | null>(null);
  const [showMappingModal, setShowMappingModal] = useState(false);
  const [rawMnyData, setRawMnyData] = useState<any[]>([]);

  // Parse OFX file format
  const parseOFX = (content: string): ParsedData => {
    console.log('Using OFX parser');
    const transactions: ParsedTransaction[] = [];
    const accountsMap = new Map<string, ParsedAccount>();
    
    // Extract account info
    const accountMatch = content.match(/<ACCTID>([^<]+)/);
    const accountTypeMatch = content.match(/<ACCTTYPE>([^<]+)/);
    const balanceMatch = content.match(/<BALAMT>([^<]+)/);
    
    const accountName = accountMatch ? `Account ${accountMatch[1]}` : 'Imported Account';
    const accountType = accountTypeMatch?.[1]?.toLowerCase() || 'checking';
    const balance = balanceMatch ? parseFloat(balanceMatch[1]) : 0;
    
    accountsMap.set(accountName, {
      name: accountName,
      type: accountType.includes('credit') ? 'credit' : 
            accountType.includes('saving') ? 'savings' : 'checking',
      balance
    });
    
    // Extract transactions
    const transactionRegex = /<STMTTRN>[\s\S]*?<\/STMTTRN>/g;
    const transactionMatches = content.match(transactionRegex) || [];
    
    for (const trans of transactionMatches) {
      const typeMatch = trans.match(/<TRNTYPE>([^<]+)/);
      const dateMatch = trans.match(/<DTPOSTED>([^<]+)/);
      const amountMatch = trans.match(/<TRNAMT>([^<]+)/);
      const nameMatch = trans.match(/<NAME>([^<]+)/);
      const memoMatch = trans.match(/<MEMO>([^<]+)/);
      
      if (dateMatch && amountMatch) {
        const dateStr = dateMatch[1];
        const year = parseInt(dateStr.substring(0, 4));
        const month = parseInt(dateStr.substring(4, 6));
        const day = parseInt(dateStr.substring(6, 8));
        
        const amount = parseFloat(amountMatch[1]);
        const description = nameMatch?.[1] || memoMatch?.[1] || 'Imported transaction';
        const type = amount < 0 ? 'expense' : 'income';
        
        transactions.push({
          date: new Date(year, month - 1, day),
          amount: Math.abs(amount),
          description,
          type,
          category: typeMatch?.[1] || 'Other'
        });
      }
    }
    
    return {
      accounts: Array.from(accountsMap.values()),
      transactions
    };
  };

  const handleFileChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const selectedFile = e.target.files?.[0];
    if (!selectedFile) return;
    
    setFile(selectedFile);
    setStatus('idle');
    setMessage('');
    setParsing(true);
    
    const fileName = selectedFile.name.toLowerCase();
    console.log('Processing file:', fileName);
    console.log('File size:', selectedFile.size, 'bytes');
    
    try {
      let parsed: ParsedData | null = null;
      
      if (fileName.endsWith('.mny')) {
        console.log('Detected MNY file');
        setMessage('Parsing Money database file... This may take a moment...');
        const arrayBuffer = await selectedFile.arrayBuffer();
        parsed = await parseMNY(arrayBuffer);
        
        // Check if we need manual mapping
        if (parsed.needsMapping && parsed.rawData) {
          setRawMnyData(parsed.rawData);
          setShowMappingModal(true);
          setParsing(false);
          return;
        }
      } else if (fileName.endsWith('.mbf')) {
        console.log('Detected MBF backup file');
        setMessage('Parsing Money backup file... This may take a moment...');
        const arrayBuffer = await selectedFile.arrayBuffer();
        parsed = await parseMBF(arrayBuffer);
        
        // Check if we need manual mapping
        if (parsed.needsMapping && parsed.rawData) {
          setRawMnyData(parsed.rawData);
          setShowMappingModal(true);
          setParsing(false);
          return;
        }
      } else if (fileName.endsWith('.qif')) {
        console.log('Detected QIF file');
        setMessage('Parsing QIF file...');
        const content = await selectedFile.text();
        console.log('QIF file content length:', content.length);
        console.log('First 200 chars:', content.substring(0, 200));
        
        // Use the enhanced QIF parser
        parsed = enhancedParseQIF(content);
      } else if (fileName.endsWith('.ofx')) {
        console.log('Detected OFX file');
        setMessage('Parsing OFX file...');
        const content = await selectedFile.text();
        parsed = parseOFX(content);
      } else {
        throw new Error('Unsupported file format. Please use .mny, .mbf, .qif, or .ofx files.');
      }
      
      if (parsed) {
        console.log('Parse complete:', parsed.accounts.length, 'accounts,', parsed.transactions.length, 'transactions');
        setPreview(parsed);
        if (parsed.warning) {
          setMessage(parsed.warning);
          setStatus('error');
        } else {
          setMessage(`Found ${parsed.accounts.length} accounts and ${parsed.transactions.length} transactions`);
          setStatus('idle');
        }
      }
    } catch (error) {
      console.error('Parse error:', error);
      setStatus('error');
      setMessage(error instanceof Error ? error.message : 'Failed to parse file');
      setPreview(null);
    } finally {
      setParsing(false);
    }
  };

  const handleMappingComplete = (mapping: any, data: any[]) => {
    console.log('Applying mapping to data...');
    const result = applyMappingToData(data, mapping);
    
    setPreview({
      accounts: result.accounts,
      transactions: result.transactions
    });
    setMessage(`Mapped ${result.accounts.length} accounts and ${result.transactions.length} transactions`);
    setShowMappingModal(false);
  };

  const handleImport = async () => {
    if (!preview) return;
    
    setImporting(true);
    try {
      console.log('Starting import of', preview.accounts.length, 'accounts and', preview.transactions.length, 'transactions');
      
      // Import accounts first
      const accountMap = new Map<string, string>();
      
      for (const account of preview.accounts) {
        const existingAccount = accounts.find(a => 
          a.name.toLowerCase() === account.name.toLowerCase()
        );
        
        if (existingAccount) {
          console.log('Account already exists:', account.name);
          accountMap.set(account.name, existingAccount.id);
          continue;
        }
        
        const newAccount = {
          name: account.name,
          type: account.type,
          balance: account.balance,
          currency: 'GBP',
          institution: 'Imported',
          lastUpdated: new Date()
        };
        console.log('Adding account:', newAccount);
        addAccount(newAccount);
        accountMap.set(account.name, `imported-${Date.now()}`);
      }
      
      // Import transactions
      const defaultAccountId = accounts[0]?.id || 'default';
      console.log('Importing', preview.transactions.length, 'transactions');
      
      for (const transaction of preview.transactions) {
        addTransaction({
          ...transaction,
          accountId: defaultAccountId,
        });
      }
      
      setStatus('success');
      setMessage(`Successfully imported ${preview.accounts.length} accounts and ${preview.transactions.length} transactions`);
      
      setTimeout(() => {
        onClose();
        setFile(null);
        setPreview(null);
        setStatus('idle');
        setMessage('');
      }, 2000);
    } catch (error) {
      console.error('Import error:', error);
      setStatus('error');
      setMessage('Failed to import data');
    } finally {
      setImporting(false);
    }
  };

  if (!isOpen) return null;

  return (
    <>
      <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
        <div className="bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-2xl max-h-[90vh] overflow-y-auto">
          <div className="flex justify-between items-center mb-4">
            <h2 className="text-xl font-semibold dark:text-white">Import Financial Data</h2>
            <button
              onClick={onClose}
              disabled={parsing}
              className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 disabled:opacity-50"
            >
              <X size={24} />
            </button>
          </div>

          <div className="mb-6">
            <p className="text-gray-600 dark:text-gray-400 mb-4">
              Import your financial data from Microsoft Money or other financial software. 
              Supported formats:
            </p>
            <ul className="list-disc list-inside text-sm text-gray-600 dark:text-gray-400 mb-4">
              <li><strong>QIF</strong> - Quicken Interchange Format (recommended for Money users)</li>
              <li><strong>OFX</strong> - Open Financial Exchange</li>
              <li><strong>MNY</strong> - Microsoft Money database files (with manual mapping)</li>
              <li><strong>MBF</strong> - Microsoft Money backup files (with manual mapping)</li>
            </ul>

            <div className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-4 mb-4">
              <div className="flex items-start gap-2">
                <Info className="text-blue-600 dark:text-blue-400 mt-0.5" size={20} />
                <div className="text-sm text-blue-800 dark:text-blue-200">
                  <p className="font-semibold mb-1">Money File Import:</p>
                  <p>For Money .mny or .mbf files, we'll show you the data and let you tell us what each column represents.</p>
                </div>
              </div>
            </div>

            <div className="border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg p-8 text-center">
              {parsing ? (
                <>
                  <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary mx-auto mb-4"></div>
                  <p className="text-gray-600 dark:text-gray-400">Parsing file...</p>
                </>
              ) : (
                <>
                  <Upload className="mx-auto text-gray-400 mb-4" size={48} />
                  <label className="cursor-pointer">
                    <span className="bg-primary text-white px-4 py-2 rounded-lg hover:bg-secondary transition-colors inline-block">
                      Choose File
                    </span>
                    <input
                      type="file"
                      accept=".mny,.mbf,.qif,.ofx"
                      onChange={handleFileChange}
                      className="hidden"
                      disabled={parsing}
                    />
                  </label>
                  <p className="text-sm text-gray-500 dark:text-gray-400 mt-2">
                    {file ? file.name : 'No file selected'}
                  </p>
                </>
              )}
            </div>
          </div>

          {preview && preview.warning && (
            <div className="mb-4 p-3 rounded-lg flex items-start gap-2 bg-orange-100 dark:bg-orange-900/20 text-orange-700 dark:text-orange-300">
              <AlertTriangle size={20} className="mt-0.5 flex-shrink-0" />
              <div>
                <p className="font-semibold mb-1">Import Notice</p>
                <p className="text-sm">{preview.warning}</p>
              </div>
            </div>
          )}

          {preview && (preview.accounts.length > 0 || preview.transactions.length > 0) && (
            <div className="mb-6 bg-gray-50 dark:bg-gray-700 rounded-lg p-4">
              <h3 className="font-semibold mb-2 dark:text-white">Preview</h3>
              <div className="grid grid-cols-2 gap-4 text-sm">
                <div>
                  <p className="text-gray-600 dark:text-gray-400">Accounts found:</p>
                  <p className="font-semibold dark:text-white">{preview.accounts.length}</p>
                  {preview.accounts.slice(0, 5).map((acc, i) => (
                    <p key={i} className="text-xs text-gray-500 dark:text-gray-400">
                      • {acc.name} ({acc.type})
                    </p>
                  ))}
                  {preview.accounts.length > 5 && (
                    <p className="text-xs text-gray-500 dark:text-gray-400">
                      • ... and {preview.accounts.length - 5} more
                    </p>
                  )}
                </div>
                <div>
                  <p className="text-gray-600 dark:text-gray-400">Transactions found:</p>
                  <p className="font-semibold dark:text-white">{preview.transactions.length}</p>
                  {preview.transactions.length > 0 && (
                    <>
                      <p className="text-xs text-gray-500 dark:text-gray-400">
                        Date range: {preview.transactions[0].date.toLocaleDateString()} - {preview.transactions[preview.transactions.length - 1].date.toLocaleDateString()}
                      </p>
                      <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                        First: {preview.transactions[0].description.substring(0, 30)}...
                      </p>
                    </>
                  )}
                </div>
              </div>
            </div>
          )}

          {message && !preview?.warning && (
            <div className={`mb-4 p-3 rounded-lg flex items-center gap-2 ${
              status === 'success' ? 'bg-green-100 dark:bg-green-900/20 text-green-700 dark:text-green-300' :
              status === 'error' ? 'bg-red-100 dark:bg-red-900/20 text-red-700 dark:text-red-300' :
              'bg-blue-100 dark:bg-blue-900/20 text-blue-700 dark:text-blue-300'
            }`}>
              {status === 'success' ? <CheckCircle size={20} /> :
               status === 'error' ? <AlertCircle size={20} /> :
               <FileText size={20} />}
              <span>{message}</span>
            </div>
          )}

          <div className="flex gap-3">
            <button
              onClick={onClose}
              disabled={parsing || importing}
              className="flex-1 px-4 py-2 border border-gray-300 dark:border-gray-600 text-gray-700 dark:text-gray-300 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-700 disabled:opacity-50"
            >
              Cancel
            </button>
            <button
              onClick={handleImport}
              disabled={!preview || importing || parsing || preview.accounts.length === 0}
              className={`flex-1 px-4 py-2 rounded-lg ${
                preview && !importing && !parsing && preview.accounts.length > 0
                  ? 'bg-primary text-white hover:bg-secondary'
                  : 'bg-gray-300 dark:bg-gray-600 text-gray-500 dark:text-gray-400 cursor-not-allowed'
              }`}
            >
              {importing ? 'Importing...' : 'Import Data'}
            </button>
          </div>
        </div>
      </div>

      <MnyMappingModal
        isOpen={showMappingModal}
        onClose={() => setShowMappingModal(false)}
        rawData={rawMnyData}
        onMappingComplete={handleMappingComplete}
      />
    </>
  );
}


=== src/components/IncomeVsExpensesChart.tsx ===
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';
import { useApp } from '../contexts/AppContext';

export default function IncomeVsExpensesChart() {
  const { transactions } = useApp();
  
  // Get last 6 months of data
  const monthlyData = [];
  const today = new Date();
  
  for (let i = 5; i >= 0; i--) {
    const date = new Date(today.getFullYear(), today.getMonth() - i, 1);
    const month = date.toLocaleDateString('en-UK', { month: 'short', year: '2-digit' });
    
    const monthTransactions = transactions.filter(t => {
      const tDate = new Date(t.date);
      return tDate.getMonth() === date.getMonth() && 
             tDate.getFullYear() === date.getFullYear();
    });
    
    const income = monthTransactions
      .filter(t => t.type === 'income')
      .reduce((sum, t) => sum + t.amount, 0);
      
    const expenses = monthTransactions
      .filter(t => t.type === 'expense')
      .reduce((sum, t) => sum + t.amount, 0);
    
    monthlyData.push({
      month,
      income: Number(income.toFixed(2)),
      expenses: Number(expenses.toFixed(2)),
      net: Number((income - expenses).toFixed(2)),
    });
  }

  const formatCurrency = (value: number) => `£${value.toFixed(0)}`;

  return (
    <div className="bg-white p-6 rounded-lg shadow">
      <h3 className="text-lg font-semibold mb-4">Income vs Expenses (Last 6 Months)</h3>
      <ResponsiveContainer width="100%" height={300}>
        <BarChart data={monthlyData}>
          <CartesianGrid strokeDasharray="3 3" />
          <XAxis dataKey="month" />
          <YAxis tickFormatter={formatCurrency} />
          <Tooltip formatter={formatCurrency} />
          <Legend />
          <Bar dataKey="income" fill="#34c759" name="Income" />
          <Bar dataKey="expenses" fill="#ff3b30" name="Expenses" />
        </BarChart>
      </ResponsiveContainer>
    </div>
  );
}


=== src/components/Layout.tsx ===
import { useState } from 'react';
import { Link, useLocation, Outlet } from 'react-router-dom';
import { Home, CreditCard, PieChart, Target, Wallet, TrendingUp, Settings, Menu, X, ArrowRightLeft, BarChart3, Goal } from 'lucide-react';

interface SidebarLinkProps {
  to: string;
  icon: React.ElementType;
  label: string;
  isCollapsed: boolean;
}

function SidebarLink({ to, icon: Icon, label, isCollapsed }: SidebarLinkProps) {
  const location = useLocation();
  const isActive = location.pathname === to;

  return (
    <Link
      to={to}
      className={`flex items-center gap-3 px-3 py-2 rounded-lg transition-colors ${
        isActive
          ? 'bg-primary text-white'
          : 'text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700'
      }`}
      title={isCollapsed ? label : undefined}
    >
      <Icon size={20} />
      {!isCollapsed && <span>{label}</span>}
    </Link>
  );
}

export default function Layout() {
  const [isSidebarCollapsed, setIsSidebarCollapsed] = useState(false);
  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);

  const toggleSidebar = () => {
    setIsSidebarCollapsed(!isSidebarCollapsed);
  };

  const toggleMobileMenu = () => {
    setIsMobileMenuOpen(!isMobileMenuOpen);
  };

  return (
    <div className="flex h-screen bg-gray-50 dark:bg-gray-900">
      {/* Sidebar */}
      <aside
        className={`${
          isSidebarCollapsed ? 'w-16' : 'w-64'
        } bg-white dark:bg-gray-800 shadow-md transition-all duration-300 hidden md:block`}
      >
        <div className="p-4">
          <div className="flex items-center justify-between mb-8">
            {!isSidebarCollapsed && (
              <h1 className="text-xl font-bold text-gray-800 dark:text-white">Money Tracker</h1>
            )}
            <button
              onClick={toggleSidebar}
              className="p-1 rounded hover:bg-gray-100 dark:hover:bg-gray-700"
            >
              <Menu size={20} className="text-gray-600 dark:text-gray-400" />
            </button>
          </div>
          <nav className="space-y-2">
            <SidebarLink to="/" icon={Home} label="Dashboard" isCollapsed={isSidebarCollapsed} />
            <SidebarLink to="/accounts" icon={Wallet} label="Accounts" isCollapsed={isSidebarCollapsed} />
            <SidebarLink to="/transactions" icon={CreditCard} label="Transactions" isCollapsed={isSidebarCollapsed} />
            <SidebarLink to="/reconciliation" icon={ArrowRightLeft} label="Reconciliation" isCollapsed={isSidebarCollapsed} />
            <SidebarLink to="/budgets" icon={Target} label="Budgets" isCollapsed={isSidebarCollapsed} />
            <SidebarLink to="/reports" icon={PieChart} label="Reports" isCollapsed={isSidebarCollapsed} />
            <SidebarLink to="/settings" icon={Settings} label="Settings" isCollapsed={isSidebarCollapsed} />
          </nav>
        </div>
      </aside>

      {/* Mobile Menu Button */}
      <button
        onClick={toggleMobileMenu}
        className="md:hidden fixed top-4 left-4 z-50 p-2 bg-white dark:bg-gray-800 rounded-lg shadow-md"
      >
        {isMobileMenuOpen ? <X size={24} /> : <Menu size={24} />}
      </button>

      {/* Mobile Menu */}
      {isMobileMenuOpen && (
        <div className="md:hidden fixed inset-0 z-40 bg-black bg-opacity-50" onClick={toggleMobileMenu}>
          <aside className="w-64 h-full bg-white dark:bg-gray-800 shadow-md" onClick={e => e.stopPropagation()}>
            <div className="p-4">
              <h1 className="text-xl font-bold text-gray-800 dark:text-white mb-8">Money Tracker</h1>
              <nav className="space-y-2">
                <SidebarLink to="/" icon={Home} label="Dashboard" isCollapsed={false} />
                <SidebarLink to="/accounts" icon={Wallet} label="Accounts" isCollapsed={false} />
                <SidebarLink to="/transactions" icon={CreditCard} label="Transactions" isCollapsed={false} />
                <SidebarLink to="/reconciliation" icon={ArrowRightLeft} label="Reconciliation" isCollapsed={false} />
                <SidebarLink to="/budgets" icon={Target} label="Budgets" isCollapsed={false} />
                <SidebarLink to="/reports" icon={PieChart} label="Reports" isCollapsed={false} />
                <SidebarLink to="/settings" icon={Settings} label="Settings" isCollapsed={false} />
              </nav>
            </div>
          </aside>
        </div>
      )}

      {/* Main Content */}
      <main className="flex-1 overflow-auto">
        <div className="p-4 md:p-8 pt-16 md:pt-8">
          <Outlet />
        </div>
      </main>
    </div>
  );
}


=== src/components/LoadingScreen.tsx ===
export default function LoadingScreen() {
  return (
    <div className="min-h-screen bg-gray-50 dark:bg-gray-900 flex items-center justify-center">
      <div className="text-center">
        <h1 className="text-2xl font-bold text-primary dark:text-pink-400 mb-4">
          Danielle's Money <span className="inline-block animate-bounce">👋</span>
        </h1>
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary mx-auto"></div>
        <p className="mt-4 text-gray-600 dark:text-gray-400">Loading your finances...</p>
      </div>
    </div>
  );
}


=== src/components/MnyMappingModal.tsx ===
import { useState, useEffect } from 'react';
import { X, AlertCircle, CheckCircle } from 'lucide-react';

interface MnyMappingModalProps {
  isOpen: boolean;
  onClose: () => void;
  rawData: any[];
  onMappingComplete: (mapping: FieldMapping, data: any[]) => void;
}

interface FieldMapping {
  date: number;
  amount: number;
  description: number;
  payee?: number;
  category?: number;
  accountName?: number;
  type?: number;
}

const FIELD_OPTIONS = [
  { value: 'ignore', label: 'Ignore this column' },
  { value: 'date', label: 'Date' },
  { value: 'amount', label: 'Amount' },
  { value: 'description', label: 'Description' },
  { value: 'payee', label: 'Payee' },
  { value: 'category', label: 'Category' },
  { value: 'accountName', label: 'Account Name' },
  { value: 'type', label: 'Transaction Type (Income/Expense)' },
  { value: 'balance', label: 'Balance' },
  { value: 'checkNumber', label: 'Check Number' },
];

export default function MnyMappingModal({ isOpen, onClose, rawData, onMappingComplete }: MnyMappingModalProps) {
  const [mapping, setMapping] = useState<Record<number, string>>({});
  const [preview, setPreview] = useState<any[]>([]);
  const [error, setError] = useState('');

  useEffect(() => {
    if (rawData && rawData.length > 0) {
      // Take first 10 records for preview
      setPreview(rawData.slice(0, 10));
    }
  }, [rawData]);

  const handleFieldChange = (columnIndex: number, fieldType: string) => {
    setMapping(prev => ({
      ...prev,
      [columnIndex]: fieldType
    }));
    setError('');
  };

  const validateMapping = (): FieldMapping | null => {
    const fieldMapping: any = {};
    let hasDate = false;
    let hasAmount = false;
    let hasDescription = false;

    Object.entries(mapping).forEach(([colIndex, fieldType]) => {
      const index = parseInt(colIndex);
      
      switch (fieldType) {
        case 'date':
          fieldMapping.date = index;
          hasDate = true;
          break;
        case 'amount':
          fieldMapping.amount = index;
          hasAmount = true;
          break;
        case 'description':
          fieldMapping.description = index;
          hasDescription = true;
          break;
        case 'payee':
          fieldMapping.payee = index;
          break;
        case 'category':
          fieldMapping.category = index;
          break;
        case 'accountName':
          fieldMapping.accountName = index;
          break;
        case 'type':
          fieldMapping.type = index;
          break;
      }
    });

    if (!hasDate || !hasAmount || !hasDescription) {
      setError('Please map at least Date, Amount, and Description fields');
      return null;
    }

    return fieldMapping as FieldMapping;
  };

  const handleSaveMapping = () => {
    const validatedMapping = validateMapping();
    if (validatedMapping) {
      onMappingComplete(validatedMapping, rawData);
    }
  };

  const formatCellValue = (value: any): string => {
    if (value === null || value === undefined) return '';
    
    // If it's a date object
    if (value instanceof Date) {
      return value.toLocaleDateString();
    }
    
    // If it's a number
    if (typeof value === 'number') {
      // Check if it might be an OLE date
      if (value > 30000 && value < 60000) {
        const date = new Date((value - 25569) * 86400 * 1000);
        if (!isNaN(date.getTime())) {
          return `${value} (${date.toLocaleDateString()})`;
        }
      }
      return value.toFixed(2);
    }
    
    // Convert to string and limit length
    const str = String(value);
    return str.length > 50 ? str.substring(0, 50) + '...' : str;
  };

  if (!isOpen) return null;

  const columns = preview.length > 0 ? Object.keys(preview[0]) : [];

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-7xl max-h-[90vh] overflow-hidden flex flex-col">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-xl font-semibold dark:text-white">Map Your Data Fields</h2>
          <button
            onClick={onClose}
            className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
          >
            <X size={24} />
          </button>
        </div>

        <div className="mb-4">
          <div className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-4">
            <div className="flex items-start gap-2">
              <AlertCircle className="text-blue-600 dark:text-blue-400 mt-0.5" size={20} />
              <div className="text-sm text-blue-800 dark:text-blue-200">
                <p className="font-semibold mb-1">Help us understand your data</p>
                <p>We've extracted data from your Money file. Please tell us what each column represents by selecting from the dropdown menus.</p>
                <p className="mt-2">Required fields: <span className="font-semibold">Date, Amount, and Description</span></p>
              </div>
            </div>
          </div>
        </div>

        <div className="flex-1 overflow-auto mb-4">
          <table className="w-full border-collapse">
            <thead>
              <tr>
                <th className="border border-gray-300 dark:border-gray-600 p-2 bg-gray-100 dark:bg-gray-700">
                  <div className="text-sm font-semibold text-gray-700 dark:text-gray-300 mb-2">Column {columns.map((_, i) => i + 1).join(', ')}</div>
                </th>
                {columns.map((_, colIndex) => (
                  <th key={colIndex} className="border border-gray-300 dark:border-gray-600 p-2 bg-gray-100 dark:bg-gray-700">
                    <select
                      className="w-full px-2 py-1 text-sm border border-gray-300 dark:border-gray-600 rounded bg-white dark:bg-gray-800 text-gray-900 dark:text-white"
                      value={mapping[colIndex] || 'ignore'}
                      onChange={(e) => handleFieldChange(colIndex, e.target.value)}
                    >
                      {FIELD_OPTIONS.map(option => (
                        <option key={option.value} value={option.value}>
                          {option.label}
                        </option>
                      ))}
                    </select>
                  </th>
                ))}
              </tr>
            </thead>
            <tbody>
              {preview.map((row, rowIndex) => (
                <tr key={rowIndex} className={rowIndex % 2 === 0 ? 'bg-gray-50 dark:bg-gray-800/50' : ''}>
                  <td className="border border-gray-300 dark:border-gray-600 p-2 text-sm font-semibold text-gray-600 dark:text-gray-400">
                    Row {rowIndex + 1}
                  </td>
                  {columns.map((col, colIndex) => (
                    <td key={colIndex} className="border border-gray-300 dark:border-gray-600 p-2 text-sm text-gray-900 dark:text-white">
                      {formatCellValue(row[col])}
                    </td>
                  ))}
                </tr>
              ))}
            </tbody>
          </table>
        </div>

        <div className="mb-4">
          <p className="text-sm text-gray-600 dark:text-gray-400">
            Showing first 10 records of {rawData.length} total records
          </p>
        </div>

        {error && (
          <div className="mb-4 p-3 rounded-lg flex items-center gap-2 bg-red-100 dark:bg-red-900/20 text-red-700 dark:text-red-300">
            <AlertCircle size={20} />
            <span>{error}</span>
          </div>
        )}

        <div className="flex gap-3">
          <button
            onClick={onClose}
            className="flex-1 px-4 py-2 border border-gray-300 dark:border-gray-600 text-gray-700 dark:text-gray-300 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-700"
          >
            Cancel
          </button>
          <button
            onClick={handleSaveMapping}
            className="flex-1 px-4 py-2 bg-primary text-white rounded-lg hover:bg-secondary flex items-center justify-center gap-2"
          >
            <CheckCircle size={20} />
            Continue with Import
          </button>
        </div>
      </div>
    </div>
  );
}


=== src/components/MobileDebug.tsx ===
import { useApp } from '../contexts/AppContext';
import { usePreferences } from '../contexts/PreferencesContext';
import { useState } from 'react';
import { generateTestData } from '../utils/generateTestData';

export default function MobileDebug() {
  const { accounts, transactions, budgets } = useApp();
  const { accentColor, theme } = usePreferences();
  const [showDebug, setShowDebug] = useState(false);
  
  // Only show on mobile devices
  const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
  
  if (!isMobile) return null;
  
  const forceLoadTestData = () => {
    try {
      const testData = generateTestData();
      localStorage.setItem('wealthtracker_accounts', JSON.stringify(testData.accounts));
      localStorage.setItem('wealthtracker_transactions', JSON.stringify(testData.transactions));
      localStorage.setItem('wealthtracker_budgets', JSON.stringify(testData.budgets));
      window.location.reload();
    } catch (error) {
      alert(`Error: ${error}`);
    }
  };
  
  return (
    <>
      <button
        onClick={() => setShowDebug(!showDebug)}
        className="fixed bottom-4 left-4 bg-gray-800 text-white p-2 rounded-full text-xs z-50"
      >
        Debug
      </button>
      
      {showDebug && (
        <div className="fixed bottom-16 left-4 bg-white dark:bg-gray-800 p-4 rounded-lg shadow-lg z-50 text-xs max-w-xs">
          <h3 className="font-bold mb-2">Debug Info</h3>
          <p>Accounts: {accounts.length}</p>
          <p>Transactions: {transactions.length}</p>
          <p>Budgets: {budgets.length}</p>
          <p>Theme: {theme}</p>
          <p>Accent: {accentColor}</p>
          <p>LocalStorage: {typeof Storage !== 'undefined' ? 'Yes' : 'No'}</p>
          <p>User Agent: {navigator.userAgent.substring(0, 50)}...</p>
          
          <button
            onClick={forceLoadTestData}
            className="mt-3 bg-purple-500 text-white px-3 py-1 rounded text-xs w-full"
          >
            Force Load Test Data
          </button>
          
          <button
            onClick={() => {
              localStorage.clear();
              window.location.reload();
            }}
            className="mt-2 bg-red-500 text-white px-3 py-1 rounded text-xs w-full"
          >
            Clear All & Reload
          </button>
        </div>
      )}
    </>
  );
}


=== src/components/NetWorthTrendChart.tsx ===
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts';
import { useApp } from '../contexts/AppContext';

export default function NetWorthTrendChart() {
  const { accounts, transactions } = useApp();

  // Helper function to format currency
  const formatCurrency = (amount: number): string => {
    return '£' + new Intl.NumberFormat('en-GB', {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    }).format(Math.abs(amount));
  };

  // Calculate net worth over the last 6 months
  const generateNetWorthData = () => {
    const data = [];
    const today = new Date();
    
    for (let i = 5; i >= 0; i--) {
      const date = new Date(today.getFullYear(), today.getMonth() - i, 1);
      const monthName = date.toLocaleString('default', { month: 'short' });
      
      // Calculate net worth at the end of that month
      const monthEnd = new Date(date.getFullYear(), date.getMonth() + 1, 0);
      
      // Get all transactions up to that month
      const relevantTransactions = transactions.filter(t => 
        new Date(t.date) <= monthEnd
      );
      
      // Calculate the balance change from transactions
      const transactionBalance = relevantTransactions.reduce((sum, t) => {
        if (t.type === 'income') return sum + t.amount;
        if (t.type === 'expense') return sum - t.amount;
        return sum;
      }, 0);
      
      // For simplicity, we'll use current account balances
      // In a real app, you'd track historical balances
      const totalBalance = accounts.reduce((sum, acc) => sum + acc.balance, 0);
      
      data.push({
        month: monthName,
        balance: totalBalance + (transactionBalance * (i / 5))
      });
    }
    
    return data;
  };

  const data = generateNetWorthData();

  return (
    <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
      <h2 className="text-xl font-semibold mb-4 dark:text-white">Net Worth Trend</h2>
      <div className="h-64">
        <ResponsiveContainer width="100%" height="100%">
          <LineChart data={data}>
            <CartesianGrid strokeDasharray="3 3" stroke="#374151" />
            <XAxis dataKey="month" stroke="#9CA3AF" />
            <YAxis 
              stroke="#9CA3AF"
              tickFormatter={(value: number) => `£${(value / 1000).toFixed(0)}k`}
            />
            <Tooltip 
              formatter={(value: number) => formatCurrency(value)}
              contentStyle={{ 
                backgroundColor: 'rgba(255, 255, 255, 0.95)',
                border: '1px solid #ccc',
                borderRadius: '8px'
              }}
            />
            <Line 
              type="monotone" 
              dataKey="balance" 
              stroke="#8B5CF6" 
              strokeWidth={2}
              dot={{ fill: '#8B5CF6' }}
            />
          </LineChart>
        </ResponsiveContainer>
      </div>
    </div>
  );
}


=== src/components/ReconciliationModal.tsx ===
import { useState, useEffect } from 'react';
import { useApp } from '../contexts/AppContext';
import { X, ArrowRight, Check, AlertCircle } from 'lucide-react';

interface ReconciliationModalProps {
  isOpen: boolean;
  onClose: () => void;
  match?: any;
  transaction?: any;
}

export default function ReconciliationModal({ isOpen, onClose, match, transaction }: ReconciliationModalProps) {
  const { transactions, accounts, updateTransaction } = useApp();
  const [selectedTransaction, setSelectedTransaction] = useState<any>(null);
  const [searchTerm, setSearchTerm] = useState('');
  const [filterAccount, setFilterAccount] = useState('');
  const [notes, setNotes] = useState('');

  useEffect(() => {
    if (match) {
      // Pre-fill with matched transaction
      setSelectedTransaction(match.outTransaction.id === transaction?.id ? match.inTransaction : match.outTransaction);
    }
  }, [match, transaction]);

  const handleReconcile = () => {
    if (!transaction && match) {
      // Reconciling a suggested match
      updateTransaction(match.outTransaction.id, {
        ...match.outTransaction,
        reconciledWith: match.inTransaction.id,
        reconciledDate: new Date(),
        reconciledNotes: notes
      });
      
      updateTransaction(match.inTransaction.id, {
        ...match.inTransaction,
        reconciledWith: match.outTransaction.id,
        reconciledDate: new Date(),
        reconciledNotes: notes
      });
    } else if (transaction && selectedTransaction) {
      // Manual reconciliation
      updateTransaction(transaction.id, {
        ...transaction,
        reconciledWith: selectedTransaction.id,
        reconciledDate: new Date(),
        reconciledNotes: notes
      });
      
      updateTransaction(selectedTransaction.id, {
        ...selectedTransaction,
        reconciledWith: transaction.id,
        reconciledDate: new Date(),
        reconciledNotes: notes
      });
    }
    
    onClose();
  };

  const filteredTransactions = transactions.filter(t => {
    if (transaction && t.id === transaction.id) return false;
    if (t.reconciledWith) return false;
    if (searchTerm && !t.description.toLowerCase().includes(searchTerm.toLowerCase())) return false;
    if (filterAccount && t.accountId !== filterAccount) return false;
    if (transaction) {
      // For manual reconciliation, show opposite type transactions
      if (transaction.type === 'expense' && t.type !== 'income') return false;
      if (transaction.type === 'income' && t.type !== 'expense') return false;
    }
    return true;
  });

  const formatCurrency = (amount: number) => {
    return new Intl.NumberFormat('en-GB', {
      style: 'currency',
      currency: 'GBP'
    }).format(amount);
  };

  const formatDate = (date: Date | string) => {
    return new Date(date).toLocaleDateString('en-GB', {
      day: '2-digit',
      month: 'short',
      year: 'numeric'
    });
  };

  const getAccountName = (accountId: string) => {
    const account = accounts.find(a => a.id === accountId);
    return account?.name || 'Unknown Account';
  };

  if (!isOpen) return null;

  const sourceTransaction = match ? match.outTransaction : transaction;
  const targetTransaction = match ? match.inTransaction : selectedTransaction;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-4xl max-h-[90vh] overflow-y-auto">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-xl font-semibold dark:text-white">
            {match ? 'Review Transfer Match' : 'Manual Reconciliation'}
          </h2>
          <button
            onClick={onClose}
            className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
          >
            <X size={24} />
          </button>
        </div>

        {/* Transaction Details */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
          {/* Source Transaction */}
          <div className="border border-gray-200 dark:border-gray-700 rounded-lg p-4">
            <h3 className="font-semibold mb-3 dark:text-white">
              {sourceTransaction?.type === 'expense' ? 'From' : 'Source'}
            </h3>
            {sourceTransaction && (
              <div className="space-y-2 text-sm">
                <p className="text-gray-600 dark:text-gray-400">
                  Account: <span className="text-gray-900 dark:text-white font-medium">
                    {getAccountName(sourceTransaction.accountId)}
                  </span>
                </p>
                <p className="text-gray-600 dark:text-gray-400">
                  Date: <span className="text-gray-900 dark:text-white font-medium">
                    {formatDate(sourceTransaction.date)}
                  </span>
                </p>
                <p className="text-gray-600 dark:text-gray-400">
                  Description: <span className="text-gray-900 dark:text-white font-medium">
                    {sourceTransaction.description}
                  </span>
                </p>
                <p className="text-gray-600 dark:text-gray-400">
                  Amount: <span className={`font-medium ${
                    sourceTransaction.type === 'expense' ? 'text-red-600 dark:text-red-400' : 'text-green-600 dark:text-green-400'
                  }`}>
                    {sourceTransaction.type === 'expense' ? '-' : '+'}{formatCurrency(sourceTransaction.amount)}
                  </span>
                </p>
              </div>
            )}
          </div>

          {/* Arrow */}
          <div className="hidden md:flex items-center justify-center absolute left-1/2 top-1/2 transform -translate-x-1/2 -translate-y-1/2">
            <ArrowRight className="text-gray-400" size={32} />
          </div>

          {/* Target Transaction */}
          <div className="border border-gray-200 dark:border-gray-700 rounded-lg p-4">
            <h3 className="font-semibold mb-3 dark:text-white">
              {sourceTransaction?.type === 'expense' ? 'To' : 'Target'}
            </h3>
            {targetTransaction ? (
              <div className="space-y-2 text-sm">
                <p className="text-gray-600 dark:text-gray-400">
                  Account: <span className="text-gray-900 dark:text-white font-medium">
                    {getAccountName(targetTransaction.accountId)}
                  </span>
                </p>
                <p className="text-gray-600 dark:text-gray-400">
                  Date: <span className="text-gray-900 dark:text-white font-medium">
                    {formatDate(targetTransaction.date)}
                  </span>
                </p>
                <p className="text-gray-600 dark:text-gray-400">
                  Description: <span className="text-gray-900 dark:text-white font-medium">
                    {targetTransaction.description}
                  </span>
                </p>
                <p className="text-gray-600 dark:text-gray-400">
                  Amount: <span className={`font-medium ${
                    targetTransaction.type === 'expense' ? 'text-red-600 dark:text-red-400' : 'text-green-600 dark:text-green-400'
                  }`}>
                    {targetTransaction.type === 'expense' ? '-' : '+'}{formatCurrency(targetTransaction.amount)}
                  </span>
                </p>
              </div>
            ) : (
              <p className="text-gray-500 dark:text-gray-400 text-sm italic">
                Select a matching transaction below
              </p>
            )}
          </div>
        </div>

        {/* Match Confidence (if applicable) */}
        {match && (
          <div className="mb-6 bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-4">
            <div className="flex items-center gap-2">
              <AlertCircle className="text-blue-600 dark:text-blue-400" size={20} />
              <p className="text-sm text-blue-800 dark:text-blue-200">
                This match has a <span className="font-semibold">{match.confidence}%</span> confidence score.
                {match.matchType === 'exact' && ' The descriptions match exactly.'}
                {match.matchType === 'fuzzy' && ' The descriptions are similar.'}
                {match.matchType === 'amount-only' && ' Only the amounts match.'}
              </p>
            </div>
          </div>
        )}

        {/* Manual Selection (if not a match) */}
        {!match && (
          <div className="mb-6">
            <h3 className="font-semibold mb-3 dark:text-white">Select Matching Transaction</h3>
            
            {/* Filters */}
            <div className="flex gap-3 mb-4">
              <input
                type="text"
                placeholder="Search transactions..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="flex-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
              />
              <select
                value={filterAccount}
                onChange={(e) => setFilterAccount(e.target.value)}
                className="px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
              >
                <option value="">All Accounts</option>
                {accounts.filter(a => transaction && a.id !== transaction.accountId).map(account => (
                  <option key={account.id} value={account.id}>{account.name}</option>
                ))}
              </select>
            </div>

            {/* Transaction List */}
            <div className="border border-gray-200 dark:border-gray-700 rounded-lg overflow-hidden max-h-64 overflow-y-auto">
              {filteredTransactions.length === 0 ? (
                <p className="text-center py-4 text-gray-500 dark:text-gray-400">
                  No matching transactions found
                </p>
              ) : (
                <table className="w-full">
                  <tbody className="divide-y divide-gray-200 dark:divide-gray-700">
                    {filteredTransactions.map((trans) => (
                      <tr
                        key={trans.id}
                        onClick={() => setSelectedTransaction(trans)}
                        className={`cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700/50 ${
                          selectedTransaction?.id === trans.id ? 'bg-blue-50 dark:bg-blue-900/20' : ''
                        }`}
                      >
                        <td className="px-4 py-3">
                          <input
                            type="radio"
                            checked={selectedTransaction?.id === trans.id}
                            onChange={() => setSelectedTransaction(trans)}
                            className="text-primary"
                          />
                        </td>
                        <td className="px-4 py-3 text-sm">
                          <p className="font-medium text-gray-900 dark:text-white">
                            {trans.description}
                          </p>
                          <p className="text-xs text-gray-500 dark:text-gray-400">
                            {getAccountName(trans.accountId)} · {formatDate(trans.date)}
                          </p>
                        </td>
                        <td className={`px-4 py-3 text-sm font-medium ${
                          trans.type === 'income' ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'
                        }`}>
                          {trans.type === 'income' ? '+' : '-'}{formatCurrency(trans.amount)}
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              )}
            </div>
          </div>
        )}

        {/* Notes */}
        <div className="mb-6">
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
            Notes (Optional)
          </label>
          <textarea
            value={notes}
            onChange={(e) => setNotes(e.target.value)}
            rows={2}
            placeholder="Add any notes about this reconciliation..."
            className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
          />
        </div>

        {/* Actions */}
        <div className="flex gap-3">
          <button
            onClick={onClose}
            className="flex-1 px-4 py-2 border border-gray-300 dark:border-gray-600 text-gray-700 dark:text-gray-300 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-700"
          >
            Cancel
          </button>
          <button
            onClick={handleReconcile}
            disabled={!match && !selectedTransaction}
            className={`flex-1 px-4 py-2 rounded-lg flex items-center justify-center gap-2 ${
              (match || selectedTransaction)
                ? 'bg-primary text-white hover:bg-secondary'
                : 'bg-gray-300 dark:bg-gray-600 text-gray-500 dark:text-gray-400 cursor-not-allowed'
            }`}
          >
            <Check size={20} />
            Reconcile Transactions
          </button>
        </div>
      </div>
    </div>
  );
}


=== src/components/RecurringTransactionModal.tsx ===
import { useState } from "react";
import { useApp } from '../contexts/AppContext';
import { X, Repeat } from "lucide-react";

interface RecurringTransactionModalProps {
  isOpen: boolean;
  onClose: () => void;
}

interface RecurringTransaction {
  id?: string;
  description: string;
  amount: number;
  type: 'income' | 'expense';
  category: string;
  accountId: string;
  frequency: 'daily' | 'weekly' | 'monthly' | 'yearly';
  startDate: string;
  endDate?: string;
  lastProcessed?: string;
}

export default function RecurringTransactionModal({ isOpen, onClose }: RecurringTransactionModalProps) {
  const { accounts, addTransaction, recurringTransactions = [], addRecurringTransaction, deleteRecurringTransaction } = useApp();
  const [formData, setFormData] = useState<RecurringTransaction>({
    description: '',
    amount: 0,
    type: 'expense',
    category: '',
    accountId: accounts[0]?.id || '',
    frequency: 'monthly',
    startDate: new Date().toISOString().split('T')[0]
  });
  const [showForm, setShowForm] = useState(false);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    addRecurringTransaction(formData);
    setFormData({
      description: '',
      amount: 0,
      type: 'expense',
      category: '',
      accountId: accounts[0]?.id || '',
      frequency: 'monthly',
      startDate: new Date().toISOString().split('T')[0]
    });
    setShowForm(false);
  };

  const processRecurringTransaction = (recurring: RecurringTransaction) => {
    const today = new Date();
    const lastProcessed = recurring.lastProcessed ? new Date(recurring.lastProcessed) : new Date(recurring.startDate);
    
    // Calculate next date based on frequency
    let nextDate = new Date(lastProcessed);
    
    switch (recurring.frequency) {
      case 'daily':
        nextDate.setDate(nextDate.getDate() + 1);
        break;
      case 'weekly':
        nextDate.setDate(nextDate.getDate() + 7);
        break;
      case 'monthly':
        nextDate.setMonth(nextDate.getMonth() + 1);
        break;
      case 'yearly':
        nextDate.setFullYear(nextDate.getFullYear() + 1);
        break;
    }

    // Process all due transactions
    while (nextDate <= today) {
      if (!recurring.endDate || nextDate <= new Date(recurring.endDate)) {
        addTransaction({
          date: nextDate,
          amount: recurring.amount,
          description: `${recurring.description} (Recurring)`,
          type: recurring.type,
          category: recurring.category,
          accountId: recurring.accountId,
          isRecurring: true,
          recurringId: recurring.id
        });
      }
      
      // Move to next occurrence
      switch (recurring.frequency) {
        case 'daily':
          nextDate.setDate(nextDate.getDate() + 1);
          break;
        case 'weekly':
          nextDate.setDate(nextDate.getDate() + 7);
          break;
        case 'monthly':
          nextDate.setMonth(nextDate.getMonth() + 1);
          break;
        case 'yearly':
          nextDate.setFullYear(nextDate.getFullYear() + 1);
          break;
      }
    }
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-2xl max-h-[90vh] overflow-y-auto">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-xl font-semibold dark:text-white flex items-center gap-2">
            <Repeat size={24} />
            Recurring Transactions
          </h2>
          <button
            onClick={onClose}
            className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
          >
            <X size={24} />
          </button>
        </div>

        {!showForm ? (
          <>
            <button
              onClick={() => setShowForm(true)}
              className="mb-4 px-4 py-2 bg-primary text-white rounded-lg hover:bg-secondary"
            >
              Add Recurring Transaction
            </button>

            <div className="space-y-3">
              {recurringTransactions?.map((recurring: RecurringTransaction) => (
                <div key={recurring.id} className="border border-gray-200 dark:border-gray-700 rounded-lg p-4">
                  <div className="flex justify-between items-start">
                    <div>
                      <h3 className="font-semibold text-gray-900 dark:text-white">
                        {recurring.description}
                      </h3>
                      <p className="text-sm text-gray-600 dark:text-gray-400">
                        {recurring.type === 'income' ? '+' : '-'}£{recurring.amount.toFixed(2)} · {recurring.frequency}
                      </p>
                      <p className="text-xs text-gray-500 dark:text-gray-500 mt-1">
                        Starts: {new Date(recurring.startDate).toLocaleDateString()}
                        {recurring.endDate && ` · Ends: ${new Date(recurring.endDate).toLocaleDateString()}`}
                      </p>
                    </div>
                    <div className="flex gap-2">
                      <button
                        onClick={() => processRecurringTransaction(recurring)}
                        className="px-3 py-1 text-sm bg-blue-500 text-white rounded hover:bg-blue-600"
                      >
                        Process Now
                      </button>
                      <button
                        onClick={() => deleteRecurringTransaction(recurring.id!)}
                        className="px-3 py-1 text-sm bg-red-500 text-white rounded hover:bg-red-600"
                      >
                        Delete
                      </button>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </>
        ) : (
          <form onSubmit={handleSubmit} className="space-y-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Description
              </label>
              <input
                type="text"
                required
                value={formData.description}
                onChange={(e) => setFormData({ ...formData, description: e.target.value })}
                className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
              />
            </div>

            <div className="grid grid-cols-2 gap-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                  Type
                </label>
                <select
                  value={formData.type}
                  onChange={(e) => setFormData({ ...formData, type: e.target.value as 'income' | 'expense' })}
                  className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
                >
                  <option value="expense">Expense</option>
                  <option value="income">Income</option>
                </select>
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                  Amount
                </label>
                <input
                  type="number"
                  required
                  step="0.01"
                  value={formData.amount}
                  onChange={(e) => setFormData({ ...formData, amount: parseFloat(e.target.value) || 0 })}
                  className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
                />
              </div>
            </div>

            <div className="grid grid-cols-2 gap-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                  Category
                </label>
                <input
                  type="text"
                  required
                  value={formData.category}
                  onChange={(e) => setFormData({ ...formData, category: e.target.value })}
                  className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
                />
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                  Account
                </label>
                <select
                  value={formData.accountId}
                  onChange={(e) => setFormData({ ...formData, accountId: e.target.value })}
                  className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
                >
                  {accounts.map(account => (
                    <option key={account.id} value={account.id}>{account.name}</option>
                  ))}
                </select>
              </div>
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Frequency
              </label>
              <select
                value={formData.frequency}
                onChange={(e) => setFormData({ ...formData, frequency: e.target.value as any })}
                className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
              >
                <option value="daily">Daily</option>
                <option value="weekly">Weekly</option>
                <option value="monthly">Monthly</option>
                <option value="yearly">Yearly</option>
              </select>
            </div>

            <div className="grid grid-cols-2 gap-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                  Start Date
                </label>
                <input
                  type="date"
                  required
                  value={formData.startDate}
                  onChange={(e) => setFormData({ ...formData, startDate: e.target.value })}
                  className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
                />
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                  End Date (Optional)
                </label>
                <input
                  type="date"
                  value={formData.endDate || ''}
                  onChange={(e) => setFormData({ ...formData, endDate: e.target.value })}
                  className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
                />
              </div>
            </div>

            <div className="flex gap-3">
              <button
                type="button"
                onClick={() => setShowForm(false)}
                className="flex-1 px-4 py-2 border border-gray-300 dark:border-gray-600 text-gray-700 dark:text-gray-300 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-700"
              >
                Cancel
              </button>
              <button
                type="submit"
                className="flex-1 px-4 py-2 bg-primary text-white rounded-lg hover:bg-secondary"
              >
                Add Recurring Transaction
              </button>
            </div>
          </form>
        )}
      </div>
    </div>
  );
}


=== src/components/SpendingByCategoryChart.tsx ===
import { PieChart, Pie, Cell, ResponsiveContainer, Tooltip } from 'recharts';
import { useApp } from '../contexts/AppContext';

export default function SpendingByCategoryChart() {
  const { transactions } = useApp();

  // Helper function to format currency
  const formatCurrency = (amount: number): string => {
    return '£' + new Intl.NumberFormat('en-GB', {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    }).format(Math.abs(amount));
  };

  // Calculate spending by category
  const spendingByCategory = transactions
    .filter(t => t.type === 'expense')
    .reduce((acc, t) => {
      acc[t.category] = (acc[t.category] || 0) + t.amount;
      return acc;
    }, {} as Record<string, number>);

  const data = Object.entries(spendingByCategory)
    .map(([name, value]) => ({ name, value }))
    .sort((a, b) => b.value - a.value)
    .slice(0, 6); // Top 6 categories

  const COLORS = ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6', '#EC4899'];

  return (
    <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
      <h2 className="text-xl font-semibold mb-4 dark:text-white">Spending by Category</h2>
      {data.length === 0 ? (
        <p className="text-gray-500 dark:text-gray-400 text-center py-8">
          No expense data available
        </p>
      ) : (
        <div className="h-64">
          <ResponsiveContainer width="100%" height="100%">
            <PieChart>
              <Pie
                data={data}
                cx="50%"
                cy="50%"
                innerRadius={60}
                outerRadius={80}
                paddingAngle={5}
                dataKey="value"
              >
                {data.map((_, index) => (
                  <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                ))}
              </Pie>
              <Tooltip 
                formatter={(value: number) => formatCurrency(value)}
                contentStyle={{ 
                  backgroundColor: 'rgba(255, 255, 255, 0.95)',
                  border: '1px solid #ccc',
                  borderRadius: '8px'
                }}
              />
            </PieChart>
          </ResponsiveContainer>
        </div>
      )}
    </div>
  );
}


=== src/components/SplitTransactionModal.tsx ===
import { useState, useEffect } from 'react';
import { useApp } from '../contexts/AppContext';
import { X, Plus, Trash2 } from 'lucide-react';

interface SplitTransactionModalProps {
  isOpen: boolean;
  onClose: () => void;
  transaction: any;
}

interface SplitItem {
  category: string;
  amount: number;
  description: string;
}

export default function SplitTransactionModal({ isOpen, onClose, transaction }: SplitTransactionModalProps) {
  const { updateTransaction, addTransaction, deleteTransaction } = useApp();
  const [splits, setSplits] = useState<SplitItem[]>([
    { category: '', amount: 0, description: '' }
  ]);
  const [remainingAmount, setRemainingAmount] = useState(0);

  useEffect(() => {
    if (transaction) {
      // If transaction already has splits, load them
      if (transaction.splits) {
        setSplits(transaction.splits);
      } else {
        // Initialize with transaction amount
        setSplits([{ 
          category: transaction.category, 
          amount: transaction.amount, 
          description: transaction.description 
        }]);
      }
    }
  }, [transaction]);

  useEffect(() => {
    if (transaction) {
      const totalSplit = splits.reduce((sum, split) => sum + split.amount, 0);
      setRemainingAmount(transaction.amount - totalSplit);
    }
  }, [splits, transaction]);

  const handleAddSplit = () => {
    setSplits([...splits, { category: '', amount: remainingAmount > 0 ? remainingAmount : 0, description: '' }]);
  };

  const handleRemoveSplit = (index: number) => {
    setSplits(splits.filter((_, i) => i !== index));
  };

  const handleSplitChange = (index: number, field: keyof SplitItem, value: any) => {
    const newSplits = [...splits];
    newSplits[index] = { ...newSplits[index], [field]: value };
    setSplits(newSplits);
  };

  const handleSave = () => {
    if (Math.abs(remainingAmount) > 0.01) {
      alert('Split amounts must equal the transaction total');
      return;
    }

    if (splits.length === 1) {
      // Just update the original transaction
      updateTransaction(transaction.id, {
        ...transaction,
        category: splits[0].category,
        description: splits[0].description
      });
    } else {
      // Delete original transaction and create split transactions
      deleteTransaction(transaction.id);
      
      splits.forEach((split, index) => {
        addTransaction({
          date: transaction.date,
          amount: split.amount,
          description: `${split.description} (Split ${index + 1}/${splits.length})`,
          type: transaction.type,
          category: split.category,
          accountId: transaction.accountId,
          originalTransactionId: transaction.id,
          isSplit: true
        });
      });
    }

    onClose();
  };

  if (!isOpen || !transaction) return null;

  const formatCurrency = (amount: number) => {
    return new Intl.NumberFormat('en-GB', {
      style: 'currency',
      currency: 'GBP'
    }).format(amount);
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-2xl max-h-[90vh] overflow-y-auto">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-xl font-semibold dark:text-white">Split Transaction</h2>
          <button
            onClick={onClose}
            className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
          >
            <X size={24} />
          </button>
        </div>

        <div className="mb-4">
          <p className="text-sm text-gray-600 dark:text-gray-400">
            Original Amount: <span className="font-semibold">{formatCurrency(transaction.amount)}</span>
          </p>
          <p className={`text-sm ${Math.abs(remainingAmount) > 0.01 ? 'text-red-600 dark:text-red-400' : 'text-green-600 dark:text-green-400'}`}>
            Remaining: <span className="font-semibold">{formatCurrency(remainingAmount)}</span>
          </p>
        </div>

        <div className="space-y-3 mb-4">
          {splits.map((split, index) => (
            <div key={index} className="border border-gray-200 dark:border-gray-700 rounded-lg p-3">
              <div className="grid grid-cols-12 gap-2">
                <div className="col-span-4">
                  <input
                    type="text"
                    placeholder="Category"
                    value={split.category}
                    onChange={(e) => handleSplitChange(index, 'category', e.target.value)}
                    className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
                  />
                </div>
                <div className="col-span-3">
                  <input
                    type="number"
                    placeholder="Amount"
                    value={split.amount}
                    onChange={(e) => handleSplitChange(index, 'amount', parseFloat(e.target.value) || 0)}
                    step="0.01"
                    className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
                  />
                </div>
                <div className="col-span-4">
                  <input
                    type="text"
                    placeholder="Description"
                    value={split.description}
                    onChange={(e) => handleSplitChange(index, 'description', e.target.value)}
                    className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
                  />
                </div>
                <div className="col-span-1 flex items-center">
                  {splits.length > 1 && (
                    <button
                      onClick={() => handleRemoveSplit(index)}
                      className="p-2 text-red-600 hover:text-red-800 dark:text-red-400 dark:hover:text-red-300"
                    >
                      <Trash2 size={18} />
                    </button>
                  )}
                </div>
              </div>
            </div>
          ))}
        </div>

        <button
          onClick={handleAddSplit}
          className="mb-4 px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-700 flex items-center gap-2 text-gray-700 dark:text-gray-300"
        >
          <Plus size={20} />
          Add Split
        </button>

        <div className="flex gap-3">
          <button
            onClick={onClose}
            className="flex-1 px-4 py-2 border border-gray-300 dark:border-gray-600 text-gray-700 dark:text-gray-300 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-700"
          >
            Cancel
          </button>
          <button
            onClick={handleSave}
            disabled={Math.abs(remainingAmount) > 0.01}
            className={`flex-1 px-4 py-2 rounded-lg ${
              Math.abs(remainingAmount) <= 0.01
                ? 'bg-primary text-white hover:bg-secondary'
                : 'bg-gray-300 dark:bg-gray-600 text-gray-500 dark:text-gray-400 cursor-not-allowed'
            }`}
          >
            Save Split
          </button>
        </div>
      </div>
    </div>
  );
}


=== src/components/ThemeDebugger.tsx ===
import { usePreferences } from '../contexts/PreferencesContext';
import { useEffect, useState } from 'react';

export default function ThemeDebugger() {
  const { theme, actualTheme, accentColor } = usePreferences();
  const [htmlClasses, setHtmlClasses] = useState('');
  
  useEffect(() => {
    // Update HTML classes display
    const updateClasses = () => {
      setHtmlClasses(document.documentElement.className);
    };
    
    updateClasses();
    
    // Watch for class changes
    const observer = new MutationObserver(updateClasses);
    observer.observe(document.documentElement, { 
      attributes: true, 
      attributeFilter: ['class'] 
    });
    
    return () => observer.disconnect();
  }, []);
  
  return (
    <div className="fixed bottom-4 right-4 bg-white dark:bg-gray-800 p-4 rounded-lg shadow-lg border-2 border-red-500 z-50 text-black dark:text-white">
      <p className="text-xs font-mono">
        Theme: {theme} → {actualTheme}<br/>
        Accent: {accentColor}<br/>
        HTML: {htmlClasses}<br/>
        Has dark class: {htmlClasses.includes('dark') ? 'YES' : 'NO'}
      </p>
      <button 
        onClick={() => {
          document.documentElement.classList.toggle('dark');
          console.log('Manually toggled dark class');
        }}
        className="mt-2 text-xs bg-red-500 text-white px-2 py-1 rounded"
      >
        Manual Toggle Dark
      </button>
    </div>
  );
}


=== src/components/TransactionModal.tsx ===
import { useState, useEffect } from 'react';
import { useApp } from '../contexts/AppContext';
import { X, Plus } from 'lucide-react';

interface TransactionModalProps {
  isOpen: boolean;
  onClose: () => void;
  transaction?: any;
}

export default function TransactionModal({ isOpen, onClose, transaction }: TransactionModalProps) {
  const { accounts, addTransaction, updateTransaction } = useApp();
  const [formData, setFormData] = useState({
    date: new Date().toISOString().split('T')[0],
    description: '',
    amount: '',
    type: 'expense' as 'income' | 'expense',
    category: '',
    accountId: accounts[0]?.id || '',
    notes: '',
    tags: [] as string[],
    cleared: false
  });
  const [tagInput, setTagInput] = useState('');

  useEffect(() => {
    if (transaction) {
      setFormData({
        date: new Date(transaction.date).toISOString().split('T')[0],
        description: transaction.description,
        amount: transaction.amount.toString(),
        type: transaction.type,
        category: transaction.category,
        accountId: transaction.accountId,
        notes: transaction.notes || '',
        tags: transaction.tags || [],
        cleared: transaction.cleared || false
      });
    } else {
      // Reset form for new transaction
      setFormData({
        date: new Date().toISOString().split('T')[0],
        description: '',
        amount: '',
        type: 'expense',
        category: '',
        accountId: accounts[0]?.id || '',
        notes: '',
        tags: [],
        cleared: false
      });
    }
  }, [transaction, accounts]);

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    const transactionData = {
      ...formData,
      date: new Date(formData.date),
      amount: parseFloat(formData.amount),
    };

    if (transaction) {
      updateTransaction(transaction.id, transactionData);
    } else {
      addTransaction(transactionData);
    }

    onClose();
  };

  const handleAddTag = () => {
    if (tagInput.trim() && !formData.tags.includes(tagInput.trim())) {
      setFormData({
        ...formData,
        tags: [...formData.tags, tagInput.trim()]
      });
      setTagInput('');
    }
  };

  const handleRemoveTag = (tagToRemove: string) => {
    setFormData({
      ...formData,
      tags: formData.tags.filter(tag => tag !== tagToRemove)
    });
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-md">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-xl font-semibold dark:text-white">
            {transaction ? 'Edit Transaction' : 'Add Transaction'}
          </h2>
          <button
            onClick={onClose}
            className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
          >
            <X size={24} />
          </button>
        </div>

        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Date
            </label>
            <input
              type="date"
              required
              value={formData.date}
              onChange={(e) => setFormData({ ...formData, date: e.target.value })}
              className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
            />
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Description
            </label>
            <input
              type="text"
              required
              value={formData.description}
              onChange={(e) => setFormData({ ...formData, description: e.target.value })}
              className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
            />
          </div>

          <div className="grid grid-cols-2 gap-4">
            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Type
              </label>
              <select
                value={formData.type}
                onChange={(e) => setFormData({ ...formData, type: e.target.value as 'income' | 'expense' })}
                className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
              >
                <option value="expense">Expense</option>
                <option value="income">Income</option>
              </select>
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Amount
              </label>
              <input
                type="number"
                required
                step="0.01"
                value={formData.amount}
                onChange={(e) => setFormData({ ...formData, amount: e.target.value })}
                className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
              />
            </div>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Category
            </label>
            <input
              type="text"
              required
              value={formData.category}
              onChange={(e) => setFormData({ ...formData, category: e.target.value })}
              className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
            />
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Account
            </label>
            <select
              value={formData.accountId}
              onChange={(e) => setFormData({ ...formData, accountId: e.target.value })}
              className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
            >
              {accounts.map(account => (
                <option key={account.id} value={account.id}>{account.name}</option>
              ))}
            </select>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Notes (Optional)
            </label>
            <textarea
              value={formData.notes}
              onChange={(e) => setFormData({ ...formData, notes: e.target.value })}
              rows={2}
              className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
            />
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Tags
            </label>
            <div className="flex gap-2 mb-2">
              <input
                type="text"
                value={tagInput}
                onChange={(e) => setTagInput(e.target.value)}
                onKeyPress={(e) => e.key === 'Enter' && (e.preventDefault(), handleAddTag())}
                placeholder="Add a tag..."
                className="flex-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
              />
              <button
                type="button"
                onClick={handleAddTag}
                className="px-3 py-2 bg-gray-200 dark:bg-gray-700 rounded-lg hover:bg-gray-300 dark:hover:bg-gray-600"
              >
                <Plus size={20} />
              </button>
            </div>
            {formData.tags.length > 0 && (
              <div className="flex flex-wrap gap-2">
                {formData.tags.map((tag, index) => (
                  <span
                    key={index}
                    className="inline-flex items-center gap-1 px-2 py-1 rounded-full text-xs bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200"
                  >
                    {tag}
                    <button
                      type="button"
                      onClick={() => handleRemoveTag(tag)}
                      className="hover:text-blue-600 dark:hover:text-blue-400"
                    >
                      <X size={14} />
                    </button>
                  </span>
                ))}
              </div>
            )}
          </div>

          <div className="flex items-center gap-2">
            <input
              type="checkbox"
              id="cleared"
              checked={formData.cleared}
              onChange={(e) => setFormData({ ...formData, cleared: e.target.checked })}
              className="rounded border-gray-300 dark:border-gray-600"
            />
            <label htmlFor="cleared" className="text-sm text-gray-700 dark:text-gray-300">
              Transaction cleared/reconciled
            </label>
          </div>

          <div className="flex gap-3">
            <button
              type="button"
              onClick={onClose}
              className="flex-1 px-4 py-2 border border-gray-300 dark:border-gray-600 text-gray-700 dark:text-gray-300 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-700"
            >
              Cancel
            </button>
            <button
              type="submit"
              className="flex-1 px-4 py-2 bg-primary text-white rounded-lg hover:bg-secondary"
            >
              {transaction ? 'Save Changes' : 'Add Transaction'}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
}


=== src/contexts/AppContext.tsx ===
import { createContext, useContext, useState, useEffect } from "react";
import type { ReactNode } from "react";

interface Account {
  id: string;
  name: string;
  type: 'checking' | 'savings' | 'credit' | 'loan' | 'investment';
  balance: number;
  currency: string;
  institution?: string;
  lastUpdated: Date;
}

interface Transaction {
  id: string;
  date: Date;
  description: string;
  amount: number;
  type: 'income' | 'expense';
  category: string;
  accountId: string;
  tags?: string[];
  notes?: string;
  cleared?: boolean;
  isSplit?: boolean;
  originalTransactionId?: string;
  isRecurring?: boolean;
  recurringId?: string;
  reconciledWith?: string;
  reconciledDate?: Date;
  reconciledNotes?: string;
}

interface Budget {
  id: string;
  category: string;
  amount: number;
  period: "monthly" | "yearly";
  isActive?: boolean;
  spent?: number;
}

interface RecurringTransaction {
  id?: string;
  description: string;
  amount: number;
  type: 'income' | 'expense';
  category: string;
  accountId: string;
  frequency: 'daily' | 'weekly' | 'monthly' | 'yearly';
  startDate: string;
  endDate?: string;
  lastProcessed?: string;
}

interface AppContextType {
  accounts: Account[];
  transactions: Transaction[];
  budgets: Budget[];
  recurringTransactions: RecurringTransaction[];
  addAccount: (account: Omit<Account, 'id'>) => void;
  updateAccount: (id: string, account: Partial<Account>) => void;
  deleteAccount: (id: string) => void;
  addTransaction: (transaction: Omit<Transaction, 'id'>) => void;
  updateTransaction: (id: string, transaction: Partial<Transaction>) => void;
  deleteTransaction: (id: string) => void;
  addBudget: (budget: Omit<Budget, 'id'>) => void;
  updateBudget: (id: string, budget: Partial<Budget>) => void;
  deleteBudget: (id: string) => void;
  clearAllData: () => void;
  exportData: () => string;
  importData: (jsonData: string) => void;
  loadTestData: () => void;
  addRecurringTransaction: (transaction: RecurringTransaction) => void;
  deleteRecurringTransaction: (id: string) => void;
}

const AppContext = createContext<AppContextType | undefined>(undefined);

export function AppProvider({ children }: { children: ReactNode }) {
  const [accounts, setAccounts] = useState<Account[]>([]);
  const [transactions, setTransactions] = useState<Transaction[]>([]);
  const [budgets, setBudgets] = useState<Budget[]>([]);
  const [recurringTransactions, setRecurringTransactions] = useState<RecurringTransaction[]>([]);

  // Load data from localStorage on mount
  useEffect(() => {
    const savedData = localStorage.getItem('moneyTrackerData');
    if (savedData) {
      try {
        const parsedData = JSON.parse(savedData);
        if (parsedData.accounts) setAccounts(parsedData.accounts);
        if (parsedData.transactions) {
          setTransactions(parsedData.transactions.map((t: any) => ({
            ...t,
            date: new Date(t.date)
          })));
        }
        if (parsedData.budgets) setBudgets(parsedData.budgets);
        if (parsedData.recurringTransactions) setRecurringTransactions(parsedData.recurringTransactions);
      } catch (error) {
        console.error('Failed to load saved data:', error);
      }
    }
  }, []);

  // Save data to localStorage whenever it changes
  useEffect(() => {
    const dataToSave = {
      accounts,
      transactions,
      budgets,
      recurringTransactions
    };
    localStorage.setItem('moneyTrackerData', JSON.stringify(dataToSave));
  }, [accounts, transactions, budgets, recurringTransactions]);

  // Account methods
  const addAccount = (account: Omit<Account, 'id'>) => {
    const newAccount = { ...account, id: Date.now().toString() };
    setAccounts([...accounts, newAccount]);
  };

  const updateAccount = (id: string, updatedAccount: Partial<Account>) => {
    setAccounts(accounts.map(acc => 
      acc.id === id ? { ...acc, ...updatedAccount } : acc
    ));
  };

  const deleteAccount = (id: string) => {
    setAccounts(accounts.filter(acc => acc.id !== id));
    // Also delete related transactions
    setTransactions(transactions.filter(t => t.accountId !== id));
  };

  // Transaction methods
  const addTransaction = (transaction: Omit<Transaction, 'id'>) => {
    const newTransaction = { ...transaction, id: Date.now().toString() };
    setTransactions([...transactions, newTransaction]);
    
    // Update account balance
    const account = accounts.find(acc => acc.id === transaction.accountId);
    if (account) {
      const balanceChange = transaction.type === 'income' ? transaction.amount : -transaction.amount;
      updateAccount(account.id, { balance: account.balance + balanceChange });
    }
  };

  const updateTransaction = (id: string, updatedTransaction: Partial<Transaction>) => {
    const oldTransaction = transactions.find(t => t.id === id);
    if (!oldTransaction) return;

    // Update the transaction
    setTransactions(transactions.map(t => 
      t.id === id ? { ...t, ...updatedTransaction } : t
    ));

    // If amount or type changed, update account balance
    if (updatedTransaction.amount !== undefined || updatedTransaction.type !== undefined) {
      const account = accounts.find(acc => acc.id === oldTransaction.accountId);
      if (account) {
        // Reverse old transaction
        const oldBalanceChange = oldTransaction.type === 'income' ? oldTransaction.amount : -oldTransaction.amount;
        // Apply new transaction
        const newAmount = updatedTransaction.amount || oldTransaction.amount;
        const newType = updatedTransaction.type || oldTransaction.type;
        const newBalanceChange = newType === 'income' ? newAmount : -newAmount;
        
        updateAccount(account.id, { 
          balance: account.balance - oldBalanceChange + newBalanceChange 
        });
      }
    }
  };

  const deleteTransaction = (id: string) => {
    const transaction = transactions.find(t => t.id === id);
    if (!transaction) return;

    setTransactions(transactions.filter(t => t.id !== id));
    
    // Update account balance
    const account = accounts.find(acc => acc.id === transaction.accountId);
    if (account) {
      const balanceChange = transaction.type === 'income' ? -transaction.amount : transaction.amount;
      updateAccount(account.id, { balance: account.balance + balanceChange });
    }
  };

  // Budget methods
  const addBudget = (budget: Omit<Budget, 'id'>) => {
    const newBudget = { ...budget, id: Date.now().toString() };
    setBudgets([...budgets, newBudget]);
  };

  const updateBudget = (id: string, updatedBudget: Partial<Budget>) => {
    setBudgets(budgets.map(budget => 
      budget.id === id ? { ...budget, ...updatedBudget } : budget
    ));
  };

  const deleteBudget = (id: string) => {
    setBudgets(budgets.filter(budget => budget.id !== id));
  };

  // Recurring transaction methods
  const addRecurringTransaction = (transaction: RecurringTransaction) => {
    const newTransaction = { ...transaction, id: Date.now().toString() };
    setRecurringTransactions([...recurringTransactions, newTransaction]);
  };

  const deleteRecurringTransaction = (id: string) => {
    setRecurringTransactions(recurringTransactions.filter(t => t.id !== id));
  };

  // Data management
  const clearAllData = () => {
    setAccounts([]);
    setTransactions([]);
    setBudgets([]);
    setRecurringTransactions([]);
    localStorage.removeItem('moneyTrackerData');
  };

  const exportData = () => {
    return JSON.stringify({
      accounts,
      transactions,
      budgets,
      recurringTransactions,
      exportDate: new Date().toISOString()
    }, null, 2);
  };

  const importData = (jsonData: string) => {
    try {
      const data = JSON.parse(jsonData);
      if (data.accounts) setAccounts(data.accounts);
      if (data.transactions) {
        setTransactions(data.transactions.map((t: any) => ({
          ...t,
          date: new Date(t.date)
        })));
      }
      if (data.budgets) setBudgets(data.budgets);
      if (data.recurringTransactions) setRecurringTransactions(data.recurringTransactions);
    } catch (error) {
      console.error('Failed to import data:', error);
      throw error;
    }
  };

  const loadTestData = () => {
    // Sample accounts
    const testAccounts: Account[] = [
      {
        id: '1',
        name: 'Main Checking',
        type: 'checking',
        balance: 5420.50,
        currency: 'GBP',
        institution: 'HSBC',
        lastUpdated: new Date()
      },
      {
        id: '2',
        name: 'Savings Account',
        type: 'savings',
        balance: 12750.00,
        currency: 'GBP',
        institution: 'HSBC',
        lastUpdated: new Date()
      },
      {
        id: '3',
        name: 'Credit Card',
        type: 'credit',
        balance: -1234.56,
        currency: 'GBP',
        institution: 'Barclaycard',
        lastUpdated: new Date()
      },
      {
        id: '4',
        name: 'Investment Account',
        type: 'investment',
        balance: 25000.00,
        currency: 'GBP',
        institution: 'Vanguard',
        lastUpdated: new Date()
      },
      {
        id: '5',
        name: 'Mortgage',
        type: 'loan',
        balance: -185000.00,
        currency: 'GBP',
        institution: 'Nationwide',
        lastUpdated: new Date()
      }
    ];

    // Sample transactions
    const testTransactions: Transaction[] = [
      {
        id: '101',
        date: new Date('2024-01-15'),
        description: 'Salary',
        amount: 3500.00,
        type: 'income',
        category: 'Income',
        accountId: '1',
        cleared: true
      },
      {
        id: '102',
        date: new Date('2024-01-16'),
        description: 'Tesco Groceries',
        amount: 87.43,
        type: 'expense',
        category: 'Groceries',
        accountId: '1',
        tags: ['shopping', 'weekly']
      },
      {
        id: '103',
        date: new Date('2024-01-17'),
        description: 'Transfer to Savings',
        amount: 500.00,
        type: 'expense',
        category: 'Transfer',
        accountId: '1',
        notes: 'Monthly savings goal'
      },
      {
        id: '104',
        date: new Date('2024-01-17'),
        description: 'Transfer from Checking',
        amount: 500.00,
        type: 'income',
        category: 'Transfer',
        accountId: '2',
        reconciledWith: '103'
      },
      {
        id: '105',
        date: new Date('2024-01-20'),
        description: 'Electricity Bill',
        amount: 145.00,
        type: 'expense',
        category: 'Utilities',
        accountId: '1',
        isRecurring: true
      }
    ];

    // Sample budgets
    const testBudgets: Budget[] = [
      {
        id: '201',
        category: 'Groceries',
        amount: 400,
        period: 'monthly'
      },
      {
        id: '202',
        category: 'Utilities',
        amount: 200,
        period: 'monthly'
      },
      {
        id: '203',
        category: 'Entertainment',
        amount: 150,
        period: 'monthly'
      }
    ];

    setAccounts(testAccounts);
    setTransactions(testTransactions);
    setBudgets(testBudgets);
  };

  return (
    <AppContext.Provider value={{
      accounts,
      transactions,
      budgets,
      recurringTransactions,
      addAccount,
      updateAccount,
      deleteAccount,
      addTransaction,
      updateTransaction,
      deleteTransaction,
      addBudget,
      updateBudget,
      deleteBudget,
      clearAllData,
      exportData,
      importData,
      loadTestData,
      addRecurringTransaction,
      deleteRecurringTransaction
    }}>
      {children}
    </AppContext.Provider>
  );
}

export function useApp() {
  const context = useContext(AppContext);
  if (!context) {
    throw new Error('useApp must be used within AppProvider');
  }
  return context;
}


=== src/contexts/PreferencesContext.tsx ===
import { createContext, useContext, useState, useEffect } from 'react';
import type { ReactNode } from 'react';

interface PreferencesContextType {
  compactView: boolean;
  setCompactView: (value: boolean) => void;
  currency: string;
  setCurrency: (value: string) => void;
  theme: 'light' | 'dark' | 'auto';
  setTheme: (value: 'light' | 'dark' | 'auto') => void;
  actualTheme: 'light' | 'dark';
  accentColor: string;
  setAccentColor: (value: string) => void;
}

const PreferencesContext = createContext<PreferencesContextType | undefined>(undefined);

export function PreferencesProvider({ children }: { children: ReactNode }) {
  const [compactView, setCompactView] = useState(() => {
    const saved = localStorage.getItem('money_management_compact_view');
    return saved === 'true';
  });

  const [currency, setCurrency] = useState(() => {
    return localStorage.getItem('money_management_currency') || 'GBP';
  });

  const [theme, setTheme] = useState<'light' | 'dark' | 'auto'>(() => {
    const saved = localStorage.getItem('money_management_theme');
    if (!saved) {
      localStorage.setItem('money_management_theme', 'dark');
      return 'dark';
    }
    if (!['light', 'dark', 'auto'].includes(saved)) {
      return 'dark';
    }
    return saved as 'light' | 'dark' | 'auto';
  });

  const [accentColor, setAccentColor] = useState(() => {
    const saved = localStorage.getItem('money_management_accent_color');
    if (!saved || saved === 'yellow') {  // Force pink if yellow or not set
      localStorage.setItem('money_management_accent_color', 'pink');
      return 'pink';
    }
    return saved;
  });

  const [actualTheme, setActualTheme] = useState<'light' | 'dark'>('dark');

  // Handle theme changes and auto theme
  useEffect(() => {
    const updateActualTheme = () => {
      let newTheme: 'light' | 'dark' = 'light';
      
      if (theme === 'dark') {
        newTheme = 'dark';
      } else if (theme === 'auto') {
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        newTheme = prefersDark ? 'dark' : 'light';
      } else {
        newTheme = 'light';
      }
      
      setActualTheme(newTheme);
    };

    updateActualTheme();

    if (theme === 'auto') {
      const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
      const handleChange = () => updateActualTheme();
      mediaQuery.addEventListener('change', handleChange);

      return () => mediaQuery.removeEventListener('change', handleChange);
    }
  }, [theme]);

  // Apply theme classes
  useEffect(() => {
    const applyTheme = () => {
      const root = document.documentElement;
      
      root.classList.remove('dark');
      
      requestAnimationFrame(() => {
        if (actualTheme === 'dark') {
          root.classList.add('dark');
        } else {
          root.classList.remove('dark');
        }
      });
    };
    
    applyTheme();
    
    const timer = setTimeout(applyTheme, 100);
    
    return () => clearTimeout(timer);
  }, [actualTheme]);

  // Apply accent color class - force pink on mount
  useEffect(() => {
    const root = document.documentElement;
    
    // Remove all accent classes
    const accentClasses = [
      'accent-blue', 'accent-green', 'accent-purple', 'accent-orange', 
      'accent-red', 'accent-pink', 'accent-indigo', 'accent-teal', 
      'accent-yellow', 'accent-gray'
    ];
    
    accentClasses.forEach(className => {
      root.classList.remove(className);
    });
    
    // Add the selected accent class
    root.classList.add(`accent-${accentColor}`);
    
    // Force pink if yellow is detected
    if (root.classList.contains('accent-yellow')) {
      root.classList.remove('accent-yellow');
      root.classList.add('accent-pink');
    }
  }, [accentColor]);

  useEffect(() => {
    localStorage.setItem('money_management_compact_view', compactView.toString());
  }, [compactView]);

  useEffect(() => {
    localStorage.setItem('money_management_currency', currency);
  }, [currency]);

  useEffect(() => {
    localStorage.setItem('money_management_theme', theme);
  }, [theme]);

  useEffect(() => {
    localStorage.setItem('money_management_accent_color', accentColor);
  }, [accentColor]);

  return (
    <PreferencesContext.Provider value={{
      compactView,
      setCompactView,
      currency,
      setCurrency,
      theme,
      setTheme,
      actualTheme,
      accentColor,
      setAccentColor,
    }}>
      {children}
    </PreferencesContext.Provider>
  );
}

export function usePreferences() {
  const context = useContext(PreferencesContext);
  if (!context) {
    throw new Error('usePreferences must be used within PreferencesProvider');
  }
  return context;
}


=== src/main.tsx ===
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

// Remove any pre-existing dark class on app start
document.documentElement.classList.remove('dark');

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)


=== src/pages/Accounts.tsx ===
import { useState } from 'react';
import { useApp } from '../contexts/AppContext';
import AddAccountModal from '../components/AddAccountModal';
import { Plus, Wallet, PiggyBank, CreditCard, TrendingDown, TrendingUp, Edit, Trash2 } from 'lucide-react';

export default function Accounts() {
  const { accounts, updateAccount, deleteAccount } = useApp();
  const [isAddModalOpen, setIsAddModalOpen] = useState(false);
  const [editingId, setEditingId] = useState<string | null>(null);
  const [editBalance, setEditBalance] = useState('');

  // Helper function to format currency properly
  const formatCurrency = (amount: number, currency: string = 'GBP'): string => {
    const symbol = currency === 'GBP' ? '£' : currency === 'USD' ? '$' : '€';
    return symbol + new Intl.NumberFormat('en-GB', {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    }).format(Math.abs(amount));
  };

  // Group accounts by type
  const accountsByType = accounts.reduce((groups, account) => {
    const type = account.type;
    if (!groups[type]) {
      groups[type] = [];
    }
    groups[type].push(account);
    return groups;
  }, {} as Record<string, typeof accounts>);

  // Define account type metadata
  const accountTypes = [
    { 
      type: 'checking', 
      title: 'Current Accounts', 
      icon: Wallet, 
      color: 'text-blue-600 dark:text-blue-400',
      bgColor: 'bg-blue-50 dark:bg-blue-900/20',
      borderColor: 'border-blue-200 dark:border-blue-800'
    },
    { 
      type: 'savings', 
      title: 'Savings Accounts', 
      icon: PiggyBank, 
      color: 'text-green-600 dark:text-green-400',
      bgColor: 'bg-green-50 dark:bg-green-900/20',
      borderColor: 'border-green-200 dark:border-green-800'
    },
    { 
      type: 'credit', 
      title: 'Credit Cards', 
      icon: CreditCard, 
      color: 'text-orange-600 dark:text-orange-400',
      bgColor: 'bg-orange-50 dark:bg-orange-900/20',
      borderColor: 'border-orange-200 dark:border-orange-800'
    },
    { 
      type: 'loan', 
      title: 'Loans', 
      icon: TrendingDown, 
      color: 'text-red-600 dark:text-red-400',
      bgColor: 'bg-red-50 dark:bg-red-900/20',
      borderColor: 'border-red-200 dark:border-red-800'
    },
    { 
      type: 'investment', 
      title: 'Investments', 
      icon: TrendingUp, 
      color: 'text-purple-600 dark:text-purple-400',
      bgColor: 'bg-purple-50 dark:bg-purple-900/20',
      borderColor: 'border-purple-200 dark:border-purple-800'
    },
  ];

  const totalBalance = accounts.reduce((sum, acc) => sum + acc.balance, 0);
  const totalAssets = accounts.filter(acc => acc.balance > 0).reduce((sum, acc) => sum + acc.balance, 0);
  const totalLiabilities = Math.abs(accounts.filter(acc => acc.balance < 0).reduce((sum, acc) => sum + acc.balance, 0));

  const handleEdit = (accountId: string, currentBalance: number) => {
    setEditingId(accountId);
    setEditBalance(currentBalance.toString());
  };

  const handleSaveEdit = (accountId: string) => {
    updateAccount(accountId, { 
      balance: parseFloat(editBalance) || 0,
      lastUpdated: new Date()
    });
    setEditingId(null);
    setEditBalance('');
  };

  const handleDelete = (accountId: string) => {
    if (window.confirm('Are you sure you want to delete this account? All related transactions will also be deleted.')) {
      deleteAccount(accountId);
    }
  };

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-gray-900 dark:text-white">Accounts</h1>
        <button 
          onClick={() => setIsAddModalOpen(true)}
          className="bg-primary text-white px-4 py-2 rounded-lg hover:bg-secondary transition-colors flex items-center gap-2"
        >
          <Plus size={20} />
          Add Account
        </button>
      </div>

      {/* Summary Cards */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
        <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
          <p className="text-sm text-gray-500 dark:text-gray-400 mb-1">Net Worth</p>
          <p className={`text-2xl font-bold ${totalBalance >= 0 ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'}`}>
            {formatCurrency(totalBalance)}
          </p>
        </div>
        <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
          <p className="text-sm text-gray-500 dark:text-gray-400 mb-1">Total Assets</p>
          <p className="text-2xl font-bold text-blue-600 dark:text-blue-400">
            {formatCurrency(totalAssets)}
          </p>
        </div>
        <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
          <p className="text-sm text-gray-500 dark:text-gray-400 mb-1">Total Liabilities</p>
          <p className="text-2xl font-bold text-orange-600 dark:text-orange-400">
            {formatCurrency(totalLiabilities)}
          </p>
        </div>
      </div>

      {/* Accounts by Category */}
      <div className="space-y-6">
        {accountTypes.map(({ type, title, icon: Icon, color, bgColor, borderColor }) => {
          const typeAccounts = accountsByType[type] || [];
          if (typeAccounts.length === 0) return null;

          const typeTotal = typeAccounts.reduce((sum, acc) => sum + acc.balance, 0);

          return (
            <div key={type} className="bg-white dark:bg-gray-800 rounded-lg shadow overflow-hidden">
              <div className={`${bgColor} ${borderColor} border-b px-6 py-4`}>
                <div className="flex items-center justify-between">
                  <div className="flex items-center gap-3">
                    <Icon className={color} size={24} />
                    <h2 className="text-lg font-semibold text-gray-900 dark:text-white">{title}</h2>
                    <span className="text-sm text-gray-500 dark:text-gray-400">
                      ({typeAccounts.length} {typeAccounts.length === 1 ? 'account' : 'accounts'})
                    </span>
                  </div>
                  <p className={`text-lg font-semibold ${typeTotal >= 0 ? 'text-gray-900 dark:text-white' : 'text-red-600 dark:text-red-400'}`}>
                    {formatCurrency(typeTotal)}
                  </p>
                </div>
              </div>

              <div className="divide-y divide-gray-200 dark:divide-gray-700">
                {typeAccounts.map((account) => (
                  <div key={account.id} className="p-6 hover:bg-gray-50 dark:hover:bg-gray-700/50 transition-colors">
                    <div className="flex items-center justify-between">
                      <div className="flex-1">
                        <h3 className="text-lg font-medium text-gray-900 dark:text-white">
                          {account.name}
                        </h3>
                        <p className="text-sm text-gray-500 dark:text-gray-400">
                          {account.institution} • Last updated: {new Date(account.lastUpdated).toLocaleDateString()}
                        </p>
                      </div>
                      
                      <div className="flex items-center gap-4">
                        {editingId === account.id ? (
                          <div className="flex items-center gap-2">
                            <input
                              type="number"
                              step="0.01"
                              value={editBalance}
                              onChange={(e) => setEditBalance(e.target.value)}
                              className="w-32 px-2 py-1 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded"
                              autoFocus
                            />
                            <button
                              onClick={() => handleSaveEdit(account.id)}
                              className="text-green-600 dark:text-green-400 hover:text-green-700 dark:hover:text-green-300"
                            >
                              Save
                            </button>
                            <button
                              onClick={() => setEditingId(null)}
                              className="text-gray-600 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-300"
                            >
                              Cancel
                            </button>
                          </div>
                        ) : (
                          <>
                            <p className={`text-xl font-semibold ${
                              account.balance >= 0 
                                ? 'text-gray-900 dark:text-white' 
                                : 'text-red-600 dark:text-red-400'
                            }`}>
                              {formatCurrency(account.balance, account.currency)}
                            </p>
                            <div className="flex items-center gap-2">
                              <button
                                onClick={() => handleEdit(account.id, account.balance)}
                                className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200"
                              >
                                <Edit size={18} />
                              </button>
                              <button
                                onClick={() => handleDelete(account.id)}
                                className="text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-300"
                              >
                                <Trash2 size={18} />
                              </button>
                            </div>
                          </>
                        )}
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          );
        })}
      </div>

      {accounts.length === 0 && (
        <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-8 text-center">
          <p className="text-gray-500 dark:text-gray-400">
            No accounts yet. Click "Add Account" to get started!
          </p>
        </div>
      )}

      <AddAccountModal 
        isOpen={isAddModalOpen} 
        onClose={() => setIsAddModalOpen(false)} 
      />
    </div>
  );}
  

=== src/pages/Analytics.tsx ===
import { useApp } from '../contexts/AppContext';
import { BarChart3, TrendingUp, ArrowUpRight, ArrowDownRight } from 'lucide-react';
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, PieChart as RePieChart, Pie, Cell, LineChart, Line, Legend } from 'recharts';

export default function Analytics() {
  const { transactions } = useApp();

  // Helper function to format currency properly
   const formatCurrency = (amount: number): string => {
    return new Intl.NumberFormat('en-GB', {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    }).format(amount);
  };

  // Calculate spending by category
  const spendingByCategory = transactions
    .filter(t => t.type === 'expense')
    .reduce((acc, t) => {
      acc[t.category] = (acc[t.category] || 0) + t.amount;
      return acc;
    }, {} as Record<string, number>);

  const categoryData = Object.entries(spendingByCategory)
    .map(([name, value]) => ({ name, value }))
    .sort((a, b) => b.value - a.value);

  // Calculate monthly trends
  const monthlyData = Array.from({ length: 12 }, (_, i) => {
    const month = new Date(2024, i).toLocaleString('default', { month: 'short' });
    const monthTransactions = transactions.filter(t => {
      const date = new Date(t.date);
      return date.getMonth() === i && date.getFullYear() === 2024;
    });

    const income = monthTransactions
      .filter(t => t.type === 'income')
      .reduce((sum, t) => sum + t.amount, 0);

    const expenses = monthTransactions
      .filter(t => t.type === 'expense')
      .reduce((sum, t) => sum + t.amount, 0);

    return { month, income, expenses };
  });

  // Calculate account trends (mock data for demonstration)
  const accountTrends = [
    { month: 'Jul', balance: 95000 },
    { month: 'Aug', balance: 92000 },
    { month: 'Sep', balance: 94500 },
    { month: 'Oct', balance: 91000 },
    { month: 'Nov', balance: 89500 },
    { month: 'Dec', balance: 73371.37 },
  ];

  // Calculate top expenses
  const topExpenses = transactions
    .filter(t => t.type === 'expense')
    .sort((a, b) => b.amount - a.amount)
    .slice(0, 5);

  // Calculate savings rate
  const totalIncome = transactions
    .filter(t => t.type === 'income')
    .reduce((sum, t) => sum + t.amount, 0);

  const totalExpenses = transactions
    .filter(t => t.type === 'expense')
    .reduce((sum, t) => sum + t.amount, 0);

  const savingsRate = totalIncome > 0 ? ((totalIncome - totalExpenses) / totalIncome) * 100 : 0;

  const COLORS = ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6', '#EC4899', '#14B8A6', '#F97316'];

  return (
    <div>
      <h1 className="text-3xl font-bold text-gray-900 dark:text-white mb-6">Analytics</h1>

      {/* Key Metrics */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
        <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
          <div className="flex items-center justify-between">
            <div>
              <p className="text-sm text-gray-500 dark:text-gray-400">Average Monthly Income</p>
              <p className="text-2xl font-bold text-green-600 dark:text-green-400">
                {formatCurrency(totalIncome / 12)}
              </p>
            </div>
            <ArrowUpRight className="text-green-500" size={24} />
          </div>
        </div>

        <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
          <div className="flex items-center justify-between">
            <div>
              <p className="text-sm text-gray-500 dark:text-gray-400">Average Monthly Expenses</p>
              <p className="text-2xl font-bold text-red-600 dark:text-red-400">
                {formatCurrency(totalExpenses / 12)}
              </p>
            </div>
            <ArrowDownRight className="text-red-500" size={24} />
          </div>
        </div>

        <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
          <div className="flex items-center justify-between">
            <div>
              <p className="text-sm text-gray-500 dark:text-gray-400">Savings Rate</p>
              <p className="text-2xl font-bold text-blue-600 dark:text-blue-400">
                {savingsRate.toFixed(1)}%
              </p>
            </div>
            <TrendingUp className="text-blue-500" size={24} />
          </div>
        </div>

        <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
          <div className="flex items-center justify-between">
            <div>
              <p className="text-sm text-gray-500 dark:text-gray-400">Total Transactions</p>
              <p className="text-2xl font-bold text-purple-600 dark:text-purple-400">
                {transactions.length}
              </p>
            </div>
            <BarChart3 className="text-purple-500" size={24} />
          </div>
        </div>
      </div>

      {/* Income vs Expenses Chart */}
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-8">
        <h2 className="text-xl font-semibold mb-4 dark:text-white">Income vs Expenses</h2>
        <div className="h-64">
          <ResponsiveContainer width="100%" height="100%">
            <BarChart data={monthlyData}>
              <CartesianGrid strokeDasharray="3 3" stroke="#374151" />
              <XAxis dataKey="month" stroke="#9CA3AF" />
              <YAxis 
                stroke="#9CA3AF"
                tickFormatter={(value) => `£${(value / 1000).toFixed(0)}k`}
              />
              <Tooltip 
                formatter={(value: number) => formatCurrency(value)}
                contentStyle={{ 
                  backgroundColor: 'rgba(255, 255, 255, 0.95)',
                  border: '1px solid #ccc',
                  borderRadius: '8px'
                }}
              />
              <Legend />
              <Bar dataKey="income" fill="#10B981" name="Income" />
              <Bar dataKey="expenses" fill="#EF4444" name="Expenses" />
            </BarChart>
          </ResponsiveContainer>
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
        {/* Spending by Category */}
        <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
          <h2 className="text-xl font-semibold mb-4 dark:text-white">Spending by Category</h2>
          <div className="h-64">
            <ResponsiveContainer width="100%" height="100%">
              <RePieChart>
                <Pie
                  data={categoryData}
                  cx="50%"
                  cy="50%"
                  innerRadius={60}
                  outerRadius={80}
                  paddingAngle={5}
                  dataKey="value"
                  label={({ name, percent }) => `${name} ${((percent || 0) * 100).toFixed(0)}%`}
                >
                  {categoryData.map((_, index) => (
                    <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                  ))}
                </Pie>
                <Tooltip 
                  formatter={(value: number) => formatCurrency(value)}
                  contentStyle={{ 
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    border: '1px solid #ccc',
                    borderRadius: '8px'
                  }}
                />
              </RePieChart>
            </ResponsiveContainer>
          </div>
        </div>

        {/* Account Balance Trend */}
        <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
          <h2 className="text-xl font-semibold mb-4 dark:text-white">Account Balance Trend</h2>
          <div className="h-64">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={accountTrends}>
                <CartesianGrid strokeDasharray="3 3" stroke="#374151" />
                <XAxis dataKey="month" stroke="#9CA3AF" />
                <YAxis 
                  stroke="#9CA3AF"
                  tickFormatter={(value) => `£${(value / 1000).toFixed(0)}k`}
                />
                <Tooltip 
                  formatter={(value: number) => formatCurrency(value)}
                  contentStyle={{ 
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    border: '1px solid #ccc',
                    borderRadius: '8px'
                  }}
                />
                <Line 
                  type="monotone" 
                  dataKey="balance" 
                  stroke="#8B5CF6" 
                  strokeWidth={2}
                  dot={{ fill: '#8B5CF6' }}
                />
              </LineChart>
            </ResponsiveContainer>
          </div>
        </div>
      </div>

      {/* Top Expenses */}
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
        <h2 className="text-xl font-semibold mb-4 dark:text-white">Top Expenses</h2>
        <div className="space-y-3">
          {topExpenses.map((expense, index) => (
            <div key={expense.id} className="flex justify-between items-center p-3 bg-gray-50 dark:bg-gray-700 rounded-lg">
              <div className="flex items-center gap-3">
                <span className="text-2xl font-bold text-gray-400 dark:text-gray-500">
                  #{index + 1}
                </span>
                <div>
                  <p className="font-medium text-gray-900 dark:text-white">{expense.description}</p>
                  <p className="text-sm text-gray-500 dark:text-gray-400">
                    {expense.category} • {new Date(expense.date).toLocaleDateString()}
                  </p>
                </div>
              </div>
              <p className="text-lg font-semibold text-red-600 dark:text-red-400">
                -{formatCurrency(expense.amount)}
              </p>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

=== src/pages/Budget.tsx ===
import { useState } from 'react';
import { useApp } from '../contexts/AppContext';
import { PlusCircle, Edit2, Trash2, TrendingUp, TrendingDown, DollarSign } from 'lucide-react';
import BudgetModal from '../components/BudgetModal';

export default function Budgets() {
  const { budgets, transactions, updateBudget, deleteBudget } = useApp();
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingBudget, setEditingBudget] = useState<any>(null);

  // Calculate spent amounts for each budget
  const budgetsWithSpent = budgets.map(budget => {
    const now = new Date();
    const currentMonth = now.getMonth();
    const currentYear = now.getFullYear();

    // Filter transactions for this budget's category
    const categoryTransactions = transactions.filter(t => {
      if (t.category !== budget.category || t.type !== 'expense') return false;
      
      const transDate = new Date(t.date);
      if (budget.period === 'monthly') {
        return transDate.getMonth() === currentMonth && 
               transDate.getFullYear() === currentYear;
      } else {
        return transDate.getFullYear() === currentYear;
      }
    });

    const spent = categoryTransactions.reduce((sum, t) => sum + t.amount, 0);
    const percentage = (spent / budget.amount) * 100;
    const remaining = budget.amount - spent;

    return {
      ...budget,
      spent,
      percentage,
      remaining
    };
  });

  const handleEdit = (budget: any) => {
    setEditingBudget(budget);
    setIsModalOpen(true);
  };

  const handleModalClose = () => {
    setIsModalOpen(false);
    setEditingBudget(null);
  };

  const handleToggleActive = (budgetId: string, currentStatus: boolean | undefined) => {
    updateBudget(budgetId, { isActive: !currentStatus });
  };

  const getProgressColor = (percentage: number) => {
    if (percentage >= 100) return 'bg-red-500';
    if (percentage >= 80) return 'bg-yellow-500';
    return 'bg-green-500';
  };

  const formatCurrency = (amount: number) => {
    return new Intl.NumberFormat('en-GB', {
      style: 'currency',
      currency: 'GBP'
    }).format(amount);
  };

  // Calculate totals
  const totalBudgeted = budgets
    .filter(b => b.isActive !== false)
    .reduce((sum, b) => sum + b.amount, 0);
  const totalSpent = budgetsWithSpent
    .filter(b => b.isActive !== false)
    .reduce((sum, b) => sum + b.spent, 0);
  const totalRemaining = totalBudgeted - totalSpent;

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-gray-900 dark:text-white">Budgets</h1>
        <button
          onClick={() => setIsModalOpen(true)}
          className="flex items-center gap-2 px-4 py-2 bg-primary text-white rounded-lg hover:bg-secondary transition-colors"
        >
          <PlusCircle size={20} />
          Add Budget
        </button>
      </div>

      {/* Summary Cards */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
        <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow">
          <div className="flex items-center justify-between">
            <div>
              <p className="text-gray-600 dark:text-gray-400 text-sm">Total Budgeted</p>
              <p className="text-2xl font-bold text-gray-900 dark:text-white">
                {formatCurrency(totalBudgeted)}
              </p>
            </div>
            <DollarSign className="text-gray-400" size={24} />
          </div>
        </div>

        <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow">
          <div className="flex items-center justify-between">
            <div>
              <p className="text-gray-600 dark:text-gray-400 text-sm">Total Spent</p>
              <p className="text-2xl font-bold text-gray-900 dark:text-white">
                {formatCurrency(totalSpent)}
              </p>
            </div>
            <TrendingDown className="text-red-500" size={24} />
          </div>
        </div>

        <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow">
          <div className="flex items-center justify-between">
            <div>
              <p className="text-gray-600 dark:text-gray-400 text-sm">Total Remaining</p>
              <p className={`text-2xl font-bold ${
                totalRemaining >= 0 ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'
              }`}>
                {formatCurrency(totalRemaining)}
              </p>
            </div>
            <TrendingUp className={totalRemaining >= 0 ? 'text-green-500' : 'text-red-500'} size={24} />
          </div>
        </div>
      </div>

      {/* Budgets List */}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        {budgetsWithSpent.map(budget => (
          <div
            key={budget.id}
            className={`bg-white dark:bg-gray-800 p-6 rounded-lg shadow ${
              budget.isActive === false ? 'opacity-60' : ''
            }`}
          >
            <div className="flex justify-between items-start mb-4">
              <div>
                <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
                  {budget.category}
                </h3>
                <p className="text-sm text-gray-600 dark:text-gray-400">
                  {budget.period === 'monthly' ? 'Monthly' : 'Yearly'} budget
                  {budget.isActive === false && ' (Inactive)'}
                </p>
              </div>
              <div className="flex gap-2">
                <button
                  onClick={() => handleToggleActive(budget.id, budget.isActive)}
                  className={`px-3 py-1 text-sm rounded ${
                    budget.isActive !== false
                      ? 'bg-green-100 dark:bg-green-900/20 text-green-700 dark:text-green-300'
                      : 'bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300'
                  }`}
                >
                  {budget.isActive !== false ? 'Active' : 'Inactive'}
                </button>
                <button
                  onClick={() => handleEdit(budget)}
                  className="text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-300"
                >
                  <Edit2 size={18} />
                </button>
                <button
                  onClick={() => {
                    if (confirm('Delete this budget?')) {
                      deleteBudget(budget.id);
                    }
                  }}
                  className="text-red-600 hover:text-red-800 dark:text-red-400 dark:hover:text-red-300"
                >
                  <Trash2 size={18} />
                </button>
              </div>
            </div>

            <div className="space-y-3">
              <div className="flex justify-between text-sm">
                <span className="text-gray-600 dark:text-gray-400">Spent</span>
                <span className="font-medium text-gray-900 dark:text-white">
                  {formatCurrency(budget.spent)} of {formatCurrency(budget.amount)}
                </span>
              </div>

              <div className="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2">
                <div
                  className={`h-2 rounded-full transition-all ${getProgressColor(budget.percentage)}`}
                  style={{ width: `${Math.min(budget.percentage, 100)}%` }}
                />
              </div>

              <div className="flex justify-between text-sm">
                <span className="text-gray-600 dark:text-gray-400">
                  {budget.percentage.toFixed(0)}% used
                </span>
                <span className={`font-medium ${
                  budget.remaining >= 0 ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'
                }`}>
                  {formatCurrency(Math.abs(budget.remaining))} {budget.remaining >= 0 ? 'remaining' : 'over budget'}
                </span>
              </div>
            </div>
          </div>
        ))}
      </div>

      {budgets.length === 0 && (
        <div className="text-center py-12 bg-white dark:bg-gray-800 rounded-lg shadow">
          <p className="text-gray-500 dark:text-gray-400 mb-4">No budgets set up yet</p>
          <button
            onClick={() => setIsModalOpen(true)}
            className="text-primary hover:underline"
          >
            Create your first budget
          </button>
        </div>
      )}

      <BudgetModal
        isOpen={isModalOpen}
        onClose={handleModalClose}
        budget={editingBudget}
      />
    </div>
  );
}

=== src/pages/Dashboard.tsx ===
import { TrendingUp, TrendingDown, DollarSign, Wallet } from 'lucide-react';
import { useApp } from '../contexts/AppContext';
import { PieChart, Pie, Cell, ResponsiveContainer, Tooltip } from 'recharts';

export default function Dashboard() {
  const { accounts, transactions } = useApp();
  
  // Helper function to format currency properly
  const formatCurrency = (amount: number): string => {
    return new Intl.NumberFormat('en-GB', {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    }).format(amount);
  };
  
  const totalAssets = accounts
    .filter(acc => acc.balance > 0)
    .reduce((sum, acc) => sum + acc.balance, 0);
    
  const totalLiabilities = Math.abs(accounts
    .filter(acc => acc.balance < 0)
    .reduce((sum, acc) => sum + acc.balance, 0));
    
  const netWorth = totalAssets - totalLiabilities;

  // Calculate monthly income and expenses
  const currentMonth = new Date().getMonth();
  const currentYear = new Date().getFullYear();
  
  const monthlyTransactions = transactions.filter(t => {
    const transDate = new Date(t.date);
    return transDate.getMonth() === currentMonth && transDate.getFullYear() === currentYear;
  });

  const monthlyIncome = monthlyTransactions
    .filter(t => t.type === 'income')
    .reduce((sum, t) => sum + t.amount, 0);

  const monthlyExpenses = monthlyTransactions
    .filter(t => t.type === 'expense')
    .reduce((sum, t) => sum + t.amount, 0);

  // Prepare data for pie chart
  const pieData = accounts.map(acc => ({
    name: acc.name,
    value: Math.abs(acc.balance),
    color: acc.balance > 0 ? '#10b981' : '#ef4444',
  }));

  const COLORS = ['#0088FE', '#00C49F', '#FFBB28', '#FF8042', '#8884D8'];

  return (
    <div>
      <h1 className="text-3xl font-bold text-gray-900 dark:text-white mb-2">
        Welcome back, Danielle!
      </h1>
      <p className="text-gray-600 dark:text-gray-400 mb-6">
        Here's your financial overview
      </p>

      {/* Summary Cards */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
        <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
          <div className="flex items-center justify-between">
            <div>
              <p className="text-sm text-gray-500 dark:text-gray-400">Net Worth</p>
              <p className="text-2xl font-bold text-gray-900 dark:text-white">
                £{formatCurrency(netWorth)}
              </p>
            </div>
            <DollarSign className="text-primary" size={24} />
          </div>
        </div>

        <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
          <div className="flex items-center justify-between">
            <div>
              <p className="text-sm text-gray-500 dark:text-gray-400">Total Assets</p>
              <p className="text-2xl font-bold text-green-600 dark:text-green-400">
                £{formatCurrency(totalAssets)}
              </p>
            </div>
            <TrendingUp className="text-green-500" size={24} />
          </div>
        </div>

        <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
          <div className="flex items-center justify-between">
            <div>
              <p className="text-sm text-gray-500 dark:text-gray-400">Total Liabilities</p>
              <p className="text-2xl font-bold text-red-600 dark:text-red-400">
                £{formatCurrency(totalLiabilities)}
              </p>
            </div>
            <TrendingDown className="text-red-500" size={24} />
          </div>
        </div>

        <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
          <div className="flex items-center justify-between">
            <div>
              <p className="text-sm text-gray-500 dark:text-gray-400">Accounts</p>
              <p className="text-2xl font-bold text-gray-900 dark:text-white">
                {accounts.length}
              </p>
            </div>
            <Wallet className="text-primary" size={24} />
          </div>
        </div>
      </div>

      {/* Monthly Overview */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
        <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
          <h2 className="text-xl font-semibold mb-4 dark:text-white">This Month</h2>
          <div className="space-y-4">
            <div className="flex justify-between items-center">
              <span className="text-gray-600 dark:text-gray-400">Income</span>
              <span className="text-green-600 dark:text-green-400 font-semibold">
                +£{formatCurrency(monthlyIncome)}
              </span>
            </div>
            <div className="flex justify-between items-center">
              <span className="text-gray-600 dark:text-gray-400">Expenses</span>
              <span className="text-red-600 dark:text-red-400 font-semibold">
                -£{formatCurrency(monthlyExpenses)}
              </span>
            </div>
            <div className="border-t dark:border-gray-700 pt-4">
              <div className="flex justify-between items-center">
                <span className="text-gray-900 dark:text-white font-semibold">Net</span>
                <span className={`font-bold ${
                  monthlyIncome - monthlyExpenses >= 0 
                    ? 'text-green-600 dark:text-green-400' 
                    : 'text-red-600 dark:text-red-400'
                }`}>
                  £{formatCurrency(monthlyIncome - monthlyExpenses)}
                </span>
              </div>
            </div>
          </div>
        </div>

        <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
          <h2 className="text-xl font-semibold mb-4 dark:text-white">Account Distribution</h2>
          <div className="h-64">
            <ResponsiveContainer width="100%" height="100%">
              <PieChart>
                <Pie
                  data={pieData}
                  cx="50%"
                  cy="50%"
                  innerRadius={60}
                  outerRadius={80}
                  paddingAngle={5}
                  dataKey="value"
                >
                  {pieData.map((_, index) => (
                    <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                  ))}
                </Pie>
                <Tooltip 
                  formatter={(value: number) => `£${formatCurrency(value)}`}
                  contentStyle={{ 
                    backgroundColor: 'rgba(255, 255, 255, 0.95)',
                    border: '1px solid #ccc',
                    borderRadius: '8px'
                  }}
                />
              </PieChart>
            </ResponsiveContainer>
          </div>
        </div>
      </div>

      {/* Recent Transactions */}
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
        <h2 className="text-xl font-semibold mb-4 dark:text-white">Recent Transactions</h2>
        <div className="space-y-3">
          {transactions.slice(0, 5).map(transaction => (
            <div key={transaction.id} className="flex justify-between items-center py-2 border-b dark:border-gray-700 last:border-0">
              <div>
                <p className="font-medium dark:text-white">{transaction.description}</p>
                <p className="text-sm text-gray-500 dark:text-gray-400">
                  {new Date(transaction.date).toLocaleDateString()}
                </p>
              </div>
              <span className={`font-semibold ${
                transaction.type === 'income' 
                  ? 'text-green-600 dark:text-green-400' 
                  : 'text-red-600 dark:text-red-400'
              }`}>
                {transaction.type === 'income' ? '+' : '-'}£{formatCurrency(transaction.amount)}
              </span>
            </div>
          ))}
          {transactions.length === 0 && (
            <p className="text-gray-500 dark:text-gray-400 text-center py-8">
              No transactions yet
            </p>
          )}
        </div>
      </div>
    </div>
  );
}

=== src/pages/Goals.tsx ===
export default function Goals() {
  return (
    <div>
      <h1 className="text-3xl font-bold text-gray-900 mb-6">Goals</h1>
      <div className="bg-white rounded-lg shadow p-6">
        <p className="text-gray-500 text-center py-8">No goals created yet</p>
      </div>
    </div>
  );
}


=== src/pages/Investments.tsx ===
import { useState } from 'react';
import { useApp } from '../contexts/AppContext';
import { TrendingUp, TrendingDown, DollarSign, BarChart3, AlertCircle } from 'lucide-react';
import { PieChart as RePieChart, Pie, Cell, ResponsiveContainer, Tooltip, LineChart, Line, XAxis, YAxis, CartesianGrid } from 'recharts';

export default function Investments() {
  const { accounts, transactions } = useApp();
  const [selectedPeriod, setSelectedPeriod] = useState<'1M' | '3M' | '6M' | '1Y' | 'ALL'>('1Y');

  // Helper function to format currency properly
  const formatCurrency = (amount: number): string => {
    return '£' + new Intl.NumberFormat('en-GB', {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    }).format(Math.abs(amount));
  };

  // Helper function to format percentages
  const formatPercentage = (value: number): string => {
    return new Intl.NumberFormat('en-GB', {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    }).format(value) + '%';
  };

  // Get investment accounts only
  const investmentAccounts = accounts.filter(acc => acc.type === 'investment');
  
  // Calculate portfolio value from investment accounts
  const portfolioValue = investmentAccounts.reduce((sum, acc) => sum + acc.balance, 0);
  
  // Calculate invested amount from investment-related transactions
  const investmentTransactions = transactions.filter(t => 
    t.category?.toLowerCase().includes('invest') || 
    investmentAccounts.some(acc => t.accountId === acc.id)
  );
  
  const totalInvested = investmentTransactions
    .filter(t => t.type === 'expense')
    .reduce((sum, t) => sum + t.amount, 0);
    
  const totalReturn = portfolioValue - totalInvested;
  const returnPercentage = totalInvested > 0 ? ((totalReturn / totalInvested) * 100) : 0;

  // Create holdings data from investment accounts
  const holdings = investmentAccounts.map((acc) => ({
    name: acc.name,
    value: acc.balance,
    allocation: portfolioValue > 0 ? (acc.balance / portfolioValue) * 100 : 0,
    return: 0, // Would need historical data to calculate actual returns
    ticker: acc.institution || 'N/A'
  }));

  // Create performance data based on transactions
  const generatePerformanceData = () => {
    const data: Array<{ month: string; value: number }> = [];
    const today = new Date();
    
    for (let i = 11; i >= 0; i--) {
      const date = new Date(today.getFullYear(), today.getMonth() - i, 1);
      const monthTransactions = investmentTransactions.filter(t => {
        const tDate = new Date(t.date);
        return tDate.getFullYear() === date.getFullYear() && 
               tDate.getMonth() === date.getMonth();
      });
      
      const monthInvested = monthTransactions
        .filter(t => t.type === 'expense')
        .reduce((sum, t) => sum + t.amount, 0);
        
      const monthWithdrawn = monthTransactions
        .filter(t => t.type === 'income')
        .reduce((sum, t) => sum + t.amount, 0);
      
      const netInvested = monthInvested - monthWithdrawn;
      
      data.push({
        month: date.toLocaleString('default', { month: 'short' }),
        value: data.length > 0 ? data[data.length - 1].value + netInvested : totalInvested
      });
    }
    
    // Add current value
    if (data.length > 0) {
      data[data.length - 1].value = portfolioValue;
    }
    
    return data;
  };

  const performanceData = generatePerformanceData();
  const COLORS = ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6'];

  // If no investment accounts, show empty state
  if (investmentAccounts.length === 0) {
    return (
      <div>
        <h1 className="text-3xl font-bold text-gray-900 dark:text-white mb-6">Investments</h1>
        
        <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-8 text-center">
          <BarChart3 className="mx-auto text-gray-400 mb-4" size={64} />
          <h2 className="text-xl font-semibold text-gray-900 dark:text-white mb-2">
            No Investment Accounts Yet
          </h2>
          <p className="text-gray-600 dark:text-gray-400 mb-4">
            Add an investment account to start tracking your portfolio performance.
          </p>
          <p className="text-sm text-gray-500 dark:text-gray-500">
            Go to Accounts → Add Account → Choose "Investment" as the account type
          </p>
        </div>
      </div>
    );
  }

  return (
    <div>
      <h1 className="text-3xl font-bold text-gray-900 dark:text-white mb-6">Investments</h1>

      {/* Summary Cards */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
        <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
          <div className="flex items-center justify-between">
            <div>
              <p className="text-sm text-gray-500 dark:text-gray-400">Portfolio Value</p>
              <p className="text-2xl font-bold text-gray-900 dark:text-white">
                {formatCurrency(portfolioValue)}
              </p>
            </div>
            <DollarSign className="text-primary" size={24} />
          </div>
        </div>

        <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
          <div className="flex items-center justify-between">
            <div>
              <p className="text-sm text-gray-500 dark:text-gray-400">Total Invested</p>
              <p className="text-2xl font-bold text-blue-600 dark:text-blue-400">
                {formatCurrency(totalInvested)}
              </p>
            </div>
            <BarChart3 className="text-blue-500" size={24} />
          </div>
        </div>

        <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
          <div className="flex items-center justify-between">
            <div>
              <p className="text-sm text-gray-500 dark:text-gray-400">Total Return</p>
              <p className={`text-2xl font-bold ${totalReturn >= 0 ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'}`}>
                {totalReturn >= 0 ? '+' : ''}{formatCurrency(totalReturn)}
              </p>
            </div>
            <TrendingUp className={totalReturn >= 0 ? 'text-green-500' : 'text-red-500'} size={24} />
          </div>
        </div>

        <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
          <div className="flex items-center justify-between">
            <div>
              <p className="text-sm text-gray-500 dark:text-gray-400">Return %</p>
              <p className={`text-2xl font-bold ${returnPercentage >= 0 ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'}`}>
                {returnPercentage >= 0 ? '+' : ''}{formatPercentage(returnPercentage)}
              </p>
            </div>
            <TrendingDown className={returnPercentage >= 0 ? 'text-green-500' : 'text-red-500'} size={24} />
          </div>
        </div>
      </div>

      {/* Performance Chart */}
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-8">
        <div className="flex justify-between items-center mb-4">
          <h2 className="text-xl font-semibold dark:text-white">Portfolio Performance</h2>
          <div className="flex gap-2">
            {['1M', '3M', '6M', '1Y', 'ALL'].map((period) => (
              <button
                key={period}
                onClick={() => setSelectedPeriod(period as any)}
                className={`px-3 py-1 text-sm rounded-lg transition-colors ${
                  selectedPeriod === period
                    ? 'bg-primary text-white'
                    : 'bg-gray-100 dark:bg-gray-700 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-600'
                }`}
              >
                {period}
              </button>
            ))}
          </div>
        </div>
        <div className="h-64">
          <ResponsiveContainer width="100%" height="100%">
            <LineChart data={performanceData}>
              <CartesianGrid strokeDasharray="3 3" stroke="#374151" />
              <XAxis dataKey="month" stroke="#9CA3AF" />
              <YAxis 
                stroke="#9CA3AF" 
                tickFormatter={(value) => `£${(value / 1000).toFixed(0)}k`}
              />
              <Tooltip 
                formatter={(value: number) => formatCurrency(value)}
                contentStyle={{ 
                  backgroundColor: 'rgba(255, 255, 255, 0.95)',
                  border: '1px solid #ccc',
                  borderRadius: '8px'
                }}
              />
              <Line 
                type="monotone" 
                dataKey="value" 
                stroke="#3B82F6" 
                strokeWidth={2}
                dot={{ fill: '#3B82F6' }}
              />
            </LineChart>
          </ResponsiveContainer>
        </div>
      </div>

      {/* Holdings */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
        {/* Holdings List */}
        <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
          <h2 className="text-xl font-semibold mb-4 dark:text-white">Holdings</h2>
          {holdings.length === 0 ? (
            <p className="text-gray-500 dark:text-gray-400 text-center py-8">
              No holdings to display
            </p>
          ) : (
            <div className="space-y-4">
              {holdings.map((holding, index) => (
                <div key={holding.name} className="border-b dark:border-gray-700 pb-4 last:border-0">
                  <div className="flex justify-between items-start mb-2">
                    <div>
                      <h3 className="font-medium text-gray-900 dark:text-white">{holding.name}</h3>
                      <p className="text-sm text-gray-500 dark:text-gray-400">{holding.ticker}</p>
                    </div>
                    <div className="text-right">
                      <p className="font-semibold text-gray-900 dark:text-white">{formatCurrency(holding.value)}</p>
                    </div>
                  </div>
                  <div className="flex items-center gap-2">
                    <div className="flex-1 bg-gray-200 dark:bg-gray-700 rounded-full h-2">
                      <div 
                        className="h-2 rounded-full"
                        style={{ 
                          width: `${holding.allocation}%`,
                          backgroundColor: COLORS[index % COLORS.length]
                        }}
                      />
                    </div>
                    <span className="text-sm text-gray-600 dark:text-gray-400 w-12 text-right">
                      {formatPercentage(holding.allocation)}
                    </span>
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>

        {/* Allocation Chart */}
        <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
          <h2 className="text-xl font-semibold mb-4 dark:text-white">Asset Allocation</h2>
          {holdings.length === 0 ? (
            <p className="text-gray-500 dark:text-gray-400 text-center py-8">
              No data to display
            </p>
          ) : (
            <>
              <div className="h-64">
                <ResponsiveContainer width="100%" height="100%">
                  <RePieChart>
                    <Pie
                      data={holdings}
                      cx="50%"
                      cy="50%"
                      innerRadius={60}
                      outerRadius={80}
                      paddingAngle={5}
                      dataKey="value"
                    >
                      {holdings.map((_, index) => (
                        <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                      ))}
                    </Pie>
                    <Tooltip 
                      formatter={(value: number) => formatCurrency(value)}
                      contentStyle={{ 
                        backgroundColor: 'rgba(255, 255, 255, 0.95)',
                        border: '1px solid #ccc',
                        borderRadius: '8px'
                      }}
                    />
                  </RePieChart>
                </ResponsiveContainer>
              </div>
              <div className="mt-4 space-y-2">
                {holdings.map((holding, index) => (
                  <div key={holding.name} className="flex items-center justify-between text-sm">
                    <div className="flex items-center gap-2">
                      <div 
                        className="w-3 h-3 rounded-full"
                        style={{ backgroundColor: COLORS[index % COLORS.length] }}
                      />
                      <span className="text-gray-700 dark:text-gray-300">{holding.ticker}</span>
                    </div>
                    <span className="text-gray-900 dark:text-white font-medium">
                      {formatPercentage(holding.allocation)}
                    </span>
                  </div>
                ))}
              </div>
            </>
          )}
        </div>
      </div>

      {/* Investment Tips */}
      <div className="mt-8 bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-6">
        <div className="flex items-start gap-3">
          <AlertCircle className="text-blue-600 dark:text-blue-400 mt-1" size={20} />
          <div>
            <h3 className="font-semibold text-blue-900 dark:text-blue-300 mb-2">Investment Tips</h3>
            <ul className="text-sm text-blue-800 dark:text-blue-200 space-y-1">
              <li>• Add investment accounts to track your portfolio</li>
              <li>• Record investment transactions with appropriate categories</li>
              <li>• Review your asset allocation regularly</li>
              <li>• Consider your risk tolerance and investment timeline</li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  );
}

=== src/pages/Reconciliation.tsx ===
import { useState, useMemo, useEffect } from 'react';
import { useApp } from '../contexts/AppContext';
import { Check, X, Search, AlertCircle, CheckCircle, Eye, Link } from 'lucide-react';
import ReconciliationModal from '../components/ReconciliationModal';

interface PotentialMatch {
  id: string;
  outTransaction: any;
  inTransaction: any;
  confidence: number;
  matchType: 'exact' | 'fuzzy' | 'amount-only';
}

export default function Reconciliation() {
  const { transactions, accounts, updateTransaction } = useApp();
  const [selectedAccount, setSelectedAccount] = useState<string>('all');
  const [showOnlyUnreconciled, setShowOnlyUnreconciled] = useState(true);
  const [potentialMatches, setPotentialMatches] = useState<PotentialMatch[]>([]);
  const [selectedMatch, setSelectedMatch] = useState<PotentialMatch | null>(null);
  const [showReconciliationModal, setShowReconciliationModal] = useState(false);
  const [manualReconcileTransaction, setManualReconcileTransaction] = useState<any>(null);

  // Find potential transfer matches
  useEffect(() => {
    const findMatches = () => {
      const matches: PotentialMatch[] = [];
      const processedPairs = new Set<string>();

      // Look for potential transfers
      transactions.forEach(outTrans => {
        if (outTrans.type === 'expense' && !outTrans.reconciledWith) {
          transactions.forEach(inTrans => {
            if (inTrans.type === 'income' && 
                !inTrans.reconciledWith && 
                outTrans.id !== inTrans.id &&
                outTrans.accountId !== inTrans.accountId) {
              
              const pairKey = [outTrans.id, inTrans.id].sort().join('-');
              if (processedPairs.has(pairKey)) return;
              processedPairs.add(pairKey);

              // Check for exact date and amount match
              const sameDate = new Date(outTrans.date).toDateString() === new Date(inTrans.date).toDateString();
              const sameAmount = Math.abs(outTrans.amount - inTrans.amount) < 0.01;
              
              if (sameDate && sameAmount) {
                // Check description similarity
                const outDesc = outTrans.description.toLowerCase();
                const inDesc = inTrans.description.toLowerCase();
                
                let confidence = 50; // Base confidence for same date and amount
                let matchType: 'exact' | 'fuzzy' | 'amount-only' = 'amount-only';

                // Check for transfer keywords
                const transferKeywords = ['transfer', 'tfr', 'from', 'to'];
                const hasTransferKeyword = transferKeywords.some(keyword => 
                  outDesc.includes(keyword) || inDesc.includes(keyword)
                );
                
                if (hasTransferKeyword) {
                  confidence += 20;
                }

                // Check if descriptions reference account names
                const outAccount = accounts.find(a => a.id === outTrans.accountId);
                const inAccount = accounts.find(a => a.id === inTrans.accountId);
                
                if (outAccount && inAccount) {
                  if (inDesc.toLowerCase().includes(outAccount.name.toLowerCase()) ||
                      outDesc.toLowerCase().includes(inAccount.name.toLowerCase())) {
                    confidence += 20;
                    matchType = 'fuzzy';
                  }
                }

                // Check for similar descriptions
                const similarity = calculateSimilarity(outDesc, inDesc);
                if (similarity > 0.7) {
                  confidence += 10;
                  if (similarity > 0.9) {
                    matchType = 'exact';
                  }
                }

                matches.push({
                  id: `${outTrans.id}-${inTrans.id}`,
                  outTransaction: outTrans,
                  inTransaction: inTrans,
                  confidence,
                  matchType
                });
              }
              
              // Also check for near-date matches (within 3 days)
              const daysDiff = Math.abs(
                (new Date(outTrans.date).getTime() - new Date(inTrans.date).getTime()) / (1000 * 60 * 60 * 24)
              );
              
              if (daysDiff <= 3 && sameAmount && !sameDate) {
                matches.push({
                  id: `${outTrans.id}-${inTrans.id}`,
                  outTransaction: outTrans,
                  inTransaction: inTrans,
                  confidence: 30 + (3 - daysDiff) * 10,
                  matchType: 'fuzzy'
                });
              }
            }
          });
        }
      });

      // Sort by confidence
      matches.sort((a, b) => b.confidence - a.confidence);
      setPotentialMatches(matches);
    };

    findMatches();
  }, [transactions, accounts]);

  // Calculate string similarity (Levenshtein distance)
  const calculateSimilarity = (str1: string, str2: string): number => {
    const longer = str1.length > str2.length ? str1 : str2;
    const shorter = str1.length > str2.length ? str2 : str1;
    
    if (longer.length === 0) return 1.0;
    
    const editDistance = (longer: string, shorter: string): number => {
      const matrix: number[][] = [];
      
      for (let i = 0; i <= shorter.length; i++) {
        matrix[i] = [i];
      }
      
      for (let j = 0; j <= longer.length; j++) {
        matrix[0][j] = j;
      }
      
      for (let i = 1; i <= shorter.length; i++) {
        for (let j = 1; j <= longer.length; j++) {
          if (shorter.charAt(i - 1) === longer.charAt(j - 1)) {
            matrix[i][j] = matrix[i - 1][j - 1];
          } else {
            matrix[i][j] = Math.min(
              matrix[i - 1][j - 1] + 1,
              matrix[i][j - 1] + 1,
              matrix[i - 1][j] + 1
            );
          }
        }
      }
      
      return matrix[shorter.length][longer.length];
    };
    
    return (longer.length - editDistance(longer, shorter)) / longer.length;
  };

  // Quick reconcile a match
  const handleQuickReconcile = (match: PotentialMatch) => {
    // Update both transactions to mark them as reconciled
    updateTransaction(match.outTransaction.id, {
      ...match.outTransaction,
      reconciledWith: match.inTransaction.id,
      reconciledDate: new Date()
    });
    
    updateTransaction(match.inTransaction.id, {
      ...match.inTransaction,
      reconciledWith: match.outTransaction.id,
      reconciledDate: new Date()
    });
  };

  // Filter transactions
  const filteredTransactions = useMemo(() => {
    return transactions.filter(transaction => {
      if (selectedAccount !== 'all' && transaction.accountId !== selectedAccount) {
        return false;
      }
      if (showOnlyUnreconciled && transaction.reconciledWith) {
        return false;
      }
      return true;
    });
  }, [transactions, selectedAccount, showOnlyUnreconciled]);

  const formatCurrency = (amount: number) => {
    return new Intl.NumberFormat('en-GB', {
      style: 'currency',
      currency: 'GBP'
    }).format(amount);
  };

  const formatDate = (date: Date | string) => {
    return new Date(date).toLocaleDateString('en-GB', {
      day: '2-digit',
      month: 'short',
      year: 'numeric'
    });
  };

  const getAccountName = (accountId: string) => {
    const account = accounts.find(a => a.id === accountId);
    return account?.name || 'Unknown Account';
  };

  const getConfidenceColor = (confidence: number) => {
    if (confidence >= 70) return 'text-green-600 dark:text-green-400';
    if (confidence >= 50) return 'text-yellow-600 dark:text-yellow-400';
    return 'text-orange-600 dark:text-orange-400';
  };

  return (
    <div>
      <h1 className="text-3xl font-bold text-gray-900 dark:text-white mb-6">Account Reconciliation</h1>

      {/* Filters */}
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-4 mb-6">
        <div className="flex flex-wrap gap-4 items-center">
          <select
            value={selectedAccount}
            onChange={(e) => setSelectedAccount(e.target.value)}
            className="px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
          >
            <option value="all">All Accounts</option>
            {accounts.map(account => (
              <option key={account.id} value={account.id}>{account.name}</option>
            ))}
          </select>

          <label className="flex items-center gap-2">
            <input
              type="checkbox"
              checked={showOnlyUnreconciled}
              onChange={(e) => setShowOnlyUnreconciled(e.target.checked)}
              className="rounded border-gray-300 dark:border-gray-600"
            />
            <span className="text-sm text-gray-700 dark:text-gray-300">Show only unreconciled</span>
          </label>
        </div>
      </div>

      {/* Potential Matches */}
      {potentialMatches.length > 0 && (
        <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-6">
          <h2 className="text-xl font-semibold mb-4 dark:text-white flex items-center gap-2">
            <Search size={24} />
            Potential Transfer Matches
          </h2>
          
          <div className="space-y-3">
            {potentialMatches.slice(0, 5).map(match => (
              <div key={match.id} className="border border-gray-200 dark:border-gray-700 rounded-lg p-4">
                <div className="flex items-center justify-between">
                  <div className="flex-1">
                    <div className="grid grid-cols-2 gap-4">
                      <div>
                        <p className="text-sm text-gray-500 dark:text-gray-400">From:</p>
                        <p className="font-medium text-gray-900 dark:text-white">
                          {getAccountName(match.outTransaction.accountId)}
                        </p>
                        <p className="text-sm text-gray-600 dark:text-gray-300">
                          {match.outTransaction.description}
                        </p>
                        <p className="text-sm text-red-600 dark:text-red-400">
                          -{formatCurrency(match.outTransaction.amount)}
                        </p>
                        <p className="text-xs text-gray-500 dark:text-gray-500">
                          {formatDate(match.outTransaction.date)}
                        </p>
                      </div>
                      
                      <div>
                        <p className="text-sm text-gray-500 dark:text-gray-400">To:</p>
                        <p className="font-medium text-gray-900 dark:text-white">
                          {getAccountName(match.inTransaction.accountId)}
                        </p>
                        <p className="text-sm text-gray-600 dark:text-gray-300">
                          {match.inTransaction.description}
                        </p>
                        <p className="text-sm text-green-600 dark:text-green-400">
                          +{formatCurrency(match.inTransaction.amount)}
                        </p>
                        <p className="text-xs text-gray-500 dark:text-gray-500">
                          {formatDate(match.inTransaction.date)}
                        </p>
                      </div>
                    </div>
                    
                    <div className="mt-2 flex items-center gap-2">
                      <span className={`text-sm font-medium ${getConfidenceColor(match.confidence)}`}>
                        {match.confidence}% match
                      </span>
                      {match.matchType === 'exact' && (
                        <span className="text-xs bg-green-100 dark:bg-green-900/20 text-green-800 dark:text-green-200 px-2 py-1 rounded">
                          Exact match
                        </span>
                      )}
                    </div>
                  </div>
                  
                  <div className="flex gap-2 ml-4">
                    <button
                      onClick={() => {
                        setSelectedMatch(match);
                        setShowReconciliationModal(true);
                      }}
                      className="p-2 text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-300"
                      title="Review"
                    >
                      <Eye size={20} />
                    </button>
                    <button
                      onClick={() => handleQuickReconcile(match)}
                      className="p-2 text-green-600 hover:text-green-800 dark:text-green-400 dark:hover:text-green-300"
                      title="Quick reconcile"
                    >
                      <Check size={20} />
                    </button>
                    <button
                      onClick={() => {
                        // Remove from suggestions
                        setPotentialMatches(potentialMatches.filter(m => m.id !== match.id));
                      }}
                      className="p-2 text-red-600 hover:text-red-800 dark:text-red-400 dark:hover:text-red-300"
                      title="Dismiss"
                    >
                      <X size={20} />
                    </button>
                  </div>
                </div>
              </div>
            ))}
          </div>
          
          {potentialMatches.length > 5 && (
            <p className="text-sm text-gray-500 dark:text-gray-400 mt-3 text-center">
              And {potentialMatches.length - 5} more potential matches...
            </p>
          )}
        </div>
      )}

      {/* Transactions List */}
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow">
        <div className="p-6 border-b border-gray-200 dark:border-gray-700">
          <h2 className="text-xl font-semibold dark:text-white">Transactions</h2>
        </div>
        
        <div className="overflow-x-auto">
          <table className="w-full">
            <thead className="bg-gray-50 dark:bg-gray-700">
              <tr>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  Date
                </th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  Account
                </th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  Description
                </th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  Amount
                </th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  Status
                </th>
                <th className="px-4 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                  Actions
                </th>
              </tr>
            </thead>
            <tbody className="divide-y divide-gray-200 dark:divide-gray-700">
              {filteredTransactions.map((transaction) => (
                <tr key={transaction.id} className="hover:bg-gray-50 dark:hover:bg-gray-700/50">
                  <td className="px-4 py-3 text-sm text-gray-900 dark:text-white">
                    {formatDate(transaction.date)}
                  </td>
                  <td className="px-4 py-3 text-sm text-gray-900 dark:text-white">
                    {getAccountName(transaction.accountId)}
                  </td>
                  <td className="px-4 py-3 text-sm text-gray-900 dark:text-white">
                    {transaction.description}
                  </td>
                  <td className={`px-4 py-3 text-sm font-medium ${
                    transaction.type === 'income' ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'
                  }`}>
                    {transaction.type === 'income' ? '+' : '-'}{formatCurrency(transaction.amount)}
                  </td>
                  <td className="px-4 py-3">
                    {transaction.reconciledWith ? (
                      <span className="inline-flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium bg-green-100 dark:bg-green-900/20 text-green-800 dark:text-green-200">
                        <CheckCircle size={14} />
                        Reconciled
                      </span>
                    ) : transaction.cleared ? (
                      <span className="inline-flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium bg-blue-100 dark:bg-blue-900/20 text-blue-800 dark:text-blue-200">
                        <Check size={14} />
                        Cleared
                      </span>
                    ) : (
                      <span className="inline-flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium bg-gray-100 dark:bg-gray-700 text-gray-800 dark:text-gray-200">
                        <AlertCircle size={14} />
                        Pending
                      </span>
                    )}
                  </td>
                  <td className="px-4 py-3 text-right">
                    <button
                      onClick={() => {
                        setManualReconcileTransaction(transaction);
                        setShowReconciliationModal(true);
                      }}
                      className="text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-300"
                    >
                      <Link size={18} />
                    </button>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </div>

      {/* Reconciliation Modal */}
      <ReconciliationModal
        isOpen={showReconciliationModal}
        onClose={() => {
          setShowReconciliationModal(false);
          setSelectedMatch(null);
          setManualReconcileTransaction(null);
        }}
        match={selectedMatch}
        transaction={manualReconcileTransaction}
      />
    </div>
  );
}


=== src/pages/Reports.tsx ===
import { useState, useMemo } from 'react';
import { useApp } from '../contexts/AppContext';
import { PieChart, TrendingUp, Calendar, Download, Filter } from 'lucide-react';
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  BarElement,
  ArcElement,
  Title,
  Tooltip,
  Legend
} from 'chart.js';
import { Line, Doughnut } from 'react-chartjs-2';

// Register ChartJS components
ChartJS.register(
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  BarElement,
  ArcElement,
  Title,
  Tooltip,
  Legend
);

export default function Reports() {
  const { transactions, accounts } = useApp();
  const [dateRange, setDateRange] = useState<'month' | 'quarter' | 'year' | 'all'>('month');
  const [selectedAccount, setSelectedAccount] = useState<string>('all');

  // Filter transactions based on date range and account
  const filteredTransactions = useMemo(() => {
    const now = new Date();
    let startDate = new Date();

    switch (dateRange) {
      case 'month':
        startDate.setMonth(now.getMonth() - 1);
        break;
      case 'quarter':
        startDate.setMonth(now.getMonth() - 3);
        break;
      case 'year':
        startDate.setFullYear(now.getFullYear() - 1);
        break;
      case 'all':
        startDate = new Date(0);
        break;
    }

    return transactions.filter(t => {
      const transDate = new Date(t.date);
      const dateMatch = transDate >= startDate;
      const accountMatch = selectedAccount === 'all' || t.accountId === selectedAccount;
      return dateMatch && accountMatch;
    });
  }, [transactions, dateRange, selectedAccount]);

  // Calculate summary statistics
  const summary = useMemo(() => {
    const income = filteredTransactions
      .filter(t => t.type === 'income')
      .reduce((sum, t) => sum + t.amount, 0);
    
    const expenses = filteredTransactions
      .filter(t => t.type === 'expense')
      .reduce((sum, t) => sum + t.amount, 0);

    const netIncome = income - expenses;
    const savingsRate = income > 0 ? (netIncome / income) * 100 : 0;

    return { income, expenses, netIncome, savingsRate };
  }, [filteredTransactions]);

  // Prepare data for category breakdown
  const categoryData = useMemo(() => {
    const categoryTotals = filteredTransactions
      .filter(t => t.type === 'expense')
      .reduce((acc, t) => {
        acc[t.category] = (acc[t.category] || 0) + t.amount;
        return acc;
      }, {} as Record<string, number>);

    const sortedCategories = Object.entries(categoryTotals)
      .sort(([, a], [, b]) => b - a)
      .slice(0, 8);

    return {
      labels: sortedCategories.map(([cat]) => cat),
      datasets: [{
        data: sortedCategories.map(([, amount]) => amount),
        backgroundColor: [
          '#3B82F6', '#10B981', '#F59E0B', '#EF4444',
          '#8B5CF6', '#EC4899', '#6366F1', '#14B8A6'
        ]
      }]
    };
  }, [filteredTransactions]);

  // Prepare data for monthly trend
  const monthlyTrendData = useMemo(() => {
    const monthlyData: Record<string, { income: number; expenses: number }> = {};
    
    filteredTransactions.forEach(t => {
      const monthKey = new Date(t.date).toISOString().slice(0, 7);
      if (!monthlyData[monthKey]) {
        monthlyData[monthKey] = { income: 0, expenses: 0 };
      }
      
      if (t.type === 'income') {
        monthlyData[monthKey].income += t.amount;
      } else {
        monthlyData[monthKey].expenses += t.amount;
      }
    });

    const sortedMonths = Object.keys(monthlyData).sort();
    
    return {
      labels: sortedMonths.map(month => {
        const date = new Date(month + '-01');
        return date.toLocaleDateString('en-GB', { month: 'short', year: 'numeric' });
      }),
      datasets: [
        {
          label: 'Income',
          data: sortedMonths.map(month => monthlyData[month].income),
          borderColor: '#10B981',
          backgroundColor: '#10B98120',
          tension: 0.4
        },
        {
          label: 'Expenses',
          data: sortedMonths.map(month => monthlyData[month].expenses),
          borderColor: '#EF4444',
          backgroundColor: '#EF444420',
          tension: 0.4
        }
      ]
    };
  }, [filteredTransactions]);

  const formatCurrency = (amount: number) => {
    return new Intl.NumberFormat('en-GB', {
      style: 'currency',
      currency: 'GBP'
    }).format(amount);
  };

  const exportToCSV = () => {
    const headers = ['Date', 'Description', 'Category', 'Type', 'Amount', 'Account'];
    const rows = filteredTransactions.map(t => [
      new Date(t.date).toLocaleDateString(),
      t.description,
      t.category,
      t.type,
      t.amount.toString(),
      accounts.find(a => a.id === t.accountId)?.name || 'Unknown'
    ]);

    const csv = [headers, ...rows]
      .map(row => row.map(cell => `"${cell}"`).join(','))
      .join('\n');

    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `financial-report-${new Date().toISOString().split('T')[0]}.csv`;
    a.click();
  };

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-gray-900 dark:text-white">Reports</h1>
        <button
          onClick={exportToCSV}
          className="flex items-center gap-2 px-4 py-2 bg-primary text-white rounded-lg hover:bg-secondary transition-colors"
        >
          <Download size={20} />
          Export CSV
        </button>
      </div>

      {/* Filters */}
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-4 mb-6">
        <div className="flex flex-wrap gap-4 items-center">
          <div className="flex items-center gap-2">
            <Calendar className="text-gray-500" size={20} />
            <select
              value={dateRange}
              onChange={(e) => setDateRange(e.target.value as any)}
              className="px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
            >
              <option value="month">Last Month</option>
              <option value="quarter">Last Quarter</option>
              <option value="year">Last Year</option>
              <option value="all">All Time</option>
            </select>
          </div>

          <div className="flex items-center gap-2">
            <Filter className="text-gray-500" size={20} />
            <select
              value={selectedAccount}
              onChange={(e) => setSelectedAccount(e.target.value)}
              className="px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
            >
              <option value="all">All Accounts</option>
              {accounts.map(account => (
                <option key={account.id} value={account.id}>{account.name}</option>
              ))}
            </select>
          </div>
        </div>
      </div>

      {/* Summary Cards */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6">
        <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow">
          <p className="text-sm text-gray-600 dark:text-gray-400 mb-1">Total Income</p>
          <p className="text-2xl font-bold text-green-600 dark:text-green-400">
            {formatCurrency(summary.income)}
          </p>
        </div>

        <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow">
          <p className="text-sm text-gray-600 dark:text-gray-400 mb-1">Total Expenses</p>
          <p className="text-2xl font-bold text-red-600 dark:text-red-400">
            {formatCurrency(summary.expenses)}
          </p>
        </div>

        <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow">
          <p className="text-sm text-gray-600 dark:text-gray-400 mb-1">Net Income</p>
          <p className={`text-2xl font-bold ${
            summary.netIncome >= 0 ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'
          }`}>
            {formatCurrency(summary.netIncome)}
          </p>
        </div>

        <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow">
          <p className="text-sm text-gray-600 dark:text-gray-400 mb-1">Savings Rate</p>
          <p className={`text-2xl font-bold ${
            summary.savingsRate >= 20 ? 'text-green-600 dark:text-green-400' : 'text-yellow-600 dark:text-yellow-400'
          }`}>
            {summary.savingsRate.toFixed(1)}%
          </p>
        </div>
      </div>

      {/* Charts */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
        {/* Monthly Trend */}
        <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow">
          <h2 className="text-lg font-semibold mb-4 flex items-center gap-2 dark:text-white">
            <TrendingUp size={20} />
            Income vs Expenses Trend
          </h2>
          <div className="h-64">
            <Line
              data={monthlyTrendData}
              options={{
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                  legend: {
                    position: 'bottom'
                  }
                },
                scales: {
                  y: {
                    beginAtZero: true
                  }
                }
              }}
            />
          </div>
        </div>

        {/* Category Breakdown */}
        <div className="bg-white dark:bg-gray-800 p-6 rounded-lg shadow">
          <h2 className="text-lg font-semibold mb-4 flex items-center gap-2 dark:text-white">
            <PieChart size={20} />
            Expense Categories
          </h2>
          <div className="h-64">
            <Doughnut
              data={categoryData}
              options={{
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                  legend: {
                    position: 'right'
                  }
                }
              }}
            />
          </div>
        </div>
      </div>

      {/* Top Transactions */}
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow">
        <div className="p-6 border-b border-gray-200 dark:border-gray-700">
          <h2 className="text-lg font-semibold dark:text-white">Top Transactions</h2>
        </div>
        <div className="overflow-x-auto">
          <table className="w-full">
            <thead className="bg-gray-50 dark:bg-gray-700">
              <tr>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase">Date</th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase">Description</th>
                <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase">Category</th>
                <th className="px-4 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-400 uppercase">Amount</th>
              </tr>
            </thead>
            <tbody className="divide-y divide-gray-200 dark:divide-gray-700">
              {filteredTransactions
                .sort((a, b) => b.amount - a.amount)
                .slice(0, 10)
                .map((transaction) => (
                  <tr key={transaction.id}>
                    <td className="px-4 py-3 text-sm text-gray-900 dark:text-white">
                      {new Date(transaction.date).toLocaleDateString()}
                    </td>
                    <td className="px-4 py-3 text-sm text-gray-900 dark:text-white">
                      {transaction.description}
                    </td>
                    <td className="px-4 py-3 text-sm text-gray-600 dark:text-gray-400">
                      {transaction.category}
                    </td>
                    <td className={`px-4 py-3 text-sm text-right font-medium ${
                      transaction.type === 'income' ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'
                    }`}>
                      {transaction.type === 'income' ? '+' : '-'}{formatCurrency(transaction.amount)}
                    </td>
                  </tr>
                ))}
            </tbody>
          </table>
        </div>
      </div>
    </div>
  );
}


=== src/pages/Settings.tsx ===
import { useState } from 'react';
import ImportDataModal from '../components/ImportDataModal';
import { useApp } from '../contexts/AppContext';
import { usePreferences } from '../contexts/PreferencesContext';
import { Download, Trash2, Moon, Sun, Monitor, Palette, AlertCircle, Upload, Database } from 'lucide-react';

export default function Settings() {
  const { accounts, transactions, budgets, clearAllData, exportData, loadTestData } = useApp();
  const { theme, setTheme, accentColor, setAccentColor } = usePreferences();
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
  const [showImportModal, setShowImportModal] = useState(false);
  const [showTestDataConfirm, setShowTestDataConfirm] = useState(false);

  const handleExportData = () => {
    const dataStr = exportData();
    const blob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `money-tracker-export-${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  const handleClearData = () => {
    clearAllData();
    setShowDeleteConfirm(false);
    // Force reload to ensure UI updates
    setTimeout(() => {
      window.location.reload();
    }, 100);
  };

  const handleLoadTestData = () => {
    loadTestData();
    setShowTestDataConfirm(false);
  };

  const themeOptions = [
    { value: 'light', label: 'Light', icon: Sun },
    { value: 'dark', label: 'Dark', icon: Moon },
    { value: 'auto', label: 'Auto', icon: Monitor },
  ];

  const accentColors = [
    { value: 'blue', label: 'Blue', color: 'bg-blue-500' },
    { value: 'green', label: 'Green', color: 'bg-green-500' },
    { value: 'purple', label: 'Purple', color: 'bg-purple-500' },
    { value: 'orange', label: 'Orange', color: 'bg-orange-500' },
    { value: 'red', label: 'Red', color: 'bg-red-500' },
    { value: 'pink', label: 'Pink', color: 'bg-pink-500' },
    { value: 'indigo', label: 'Indigo', color: 'bg-indigo-500' },
    { value: 'teal', label: 'Teal', color: 'bg-teal-500' },
  ];

  return (
    <div>
      <h1 className="text-3xl font-bold text-gray-900 dark:text-white mb-6">Settings</h1>

      {/* Appearance */}
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-6">
        <h2 className="text-xl font-semibold mb-4 text-gray-900 dark:text-white">Appearance</h2>
        
        {/* Theme Selection */}
        <div className="mb-6">
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-3">
            Theme
          </label>
          <div className="grid grid-cols-3 gap-3">
            {themeOptions.map(({ value, label, icon: Icon }) => (
              <button
                key={value}
                onClick={() => setTheme(value as any)}
                className={`flex items-center justify-center gap-2 px-4 py-3 rounded-lg border-2 transition-colors ${
                  theme === value
                    ? 'border-primary bg-primary/10 text-primary dark:bg-primary/20 dark:text-primary'
                    : 'border-gray-300 dark:border-gray-600 hover:border-gray-400 dark:hover:border-gray-500 text-gray-700 dark:text-gray-300'
                }`}
              >
                <Icon size={20} />
                <span>{label}</span>
              </button>
            ))}
          </div>
        </div>

        {/* Accent Colour */}
        <div>
          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-3">
            Accent Colour
          </label>
          <div className="grid grid-cols-4 gap-3">
            {accentColors.map(({ value, label, color }) => (
              <button
                key={value}
                onClick={() => setAccentColor(value)}
                className={`flex items-center justify-center gap-2 px-3 py-2 rounded-lg border-2 transition-colors ${
                  accentColor === value
                    ? 'border-gray-900 dark:border-gray-100 text-gray-900 dark:text-white'
                    : 'border-gray-300 dark:border-gray-600 hover:border-gray-400 dark:hover:border-gray-500 text-gray-700 dark:text-gray-300'
                }`}
              >
                <div className={`w-4 h-4 rounded-full ${color}`} />
                <span className="text-sm">{label}</span>
              </button>
            ))}
          </div>
        </div>
      </div>

      {/* Data Management */}
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-6">
        <h2 className="text-xl font-semibold mb-4 text-gray-900 dark:text-white">Data Management</h2>
        <div className="space-y-3">
          <button
            onClick={() => setShowImportModal(true)}
            className="w-full px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors flex items-center justify-center gap-2"
          >
            <Upload size={20} />
            Import Data (MNY/MBF/QIF/OFX)
          </button>
          
          <button
            onClick={handleExportData}
            className="w-full px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors flex items-center justify-center gap-2"
          >
            <Download size={20} />
            Export Data to JSON
          </button>

          <button
            onClick={() => setShowTestDataConfirm(true)}
            className="w-full px-4 py-2 bg-purple-500 text-white rounded-lg hover:bg-purple-600 transition-colors flex items-center justify-center gap-2"
          >
            <Database size={20} />
            Load Test Data
          </button>
          
          <button
            onClick={() => setShowDeleteConfirm(true)}
            className="w-full px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors flex items-center justify-center gap-2"
          >
            <Trash2 size={20} />
            Clear All Data
          </button>
        </div>
      </div>

      {/* Delete Confirmation Dialog */}
      {showDeleteConfirm && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
          <div className="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-md w-full">
            <div className="flex items-center gap-3 mb-4">
              <AlertCircle className="text-red-500" size={24} />
              <h3 className="text-lg font-semibold text-gray-900 dark:text-white">Confirm Delete All Data</h3>
            </div>
            <p className="text-gray-600 dark:text-gray-400 mb-4">
              Are you sure you want to delete all data? This will permanently remove:
            </p>
            <ul className="list-disc list-inside text-sm text-gray-600 dark:text-gray-400 mb-6">
              <li>{accounts.length} accounts</li>
              <li>{transactions.length} transactions</li>
              <li>{budgets.length} budgets</li>
            </ul>
            <p className="text-sm font-semibold text-red-600 dark:text-red-400 mb-6">
              This action cannot be undone!
            </p>
            <div className="flex gap-3">
              <button
                onClick={() => setShowDeleteConfirm(false)}
                className="flex-1 px-4 py-2 border border-gray-300 dark:border-gray-600 text-gray-700 dark:text-gray-300 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-700"
              >
                Cancel
              </button>
              <button
                onClick={handleClearData}
                className="flex-1 px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600"
              >
                Delete All Data
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Test Data Confirmation Dialog */}
      {showTestDataConfirm && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
          <div className="bg-white dark:bg-gray-800 rounded-lg p-6 max-w-md w-full">
            <div className="flex items-center gap-3 mb-4">
              <Database className="text-purple-500" size={24} />
              <h3 className="text-lg font-semibold text-gray-900 dark:text-white">Load Test Data</h3>
            </div>
            <p className="text-gray-600 dark:text-gray-400 mb-4">
              This will load sample data to help you explore the app's features. The test data includes:
            </p>
            <ul className="list-disc list-inside text-sm text-gray-600 dark:text-gray-400 mb-6">
              <li>5 sample accounts</li>
              <li>Multiple transactions</li>
              <li>Example budgets</li>
            </ul>
            <p className="text-sm text-orange-600 dark:text-orange-400 mb-6">
              Note: This will add to your existing data, not replace it.
            </p>
            <div className="flex gap-3">
              <button
                onClick={() => setShowTestDataConfirm(false)}
                className="flex-1 px-4 py-2 border border-gray-300 dark:border-gray-600 text-gray-700 dark:text-gray-300 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-700"
              >
                Cancel
              </button>
              <button
                onClick={handleLoadTestData}
                className="flex-1 px-4 py-2 bg-purple-500 text-white rounded-lg hover:bg-purple-600"
              >
                Load Test Data
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Import Modal */}
      <ImportDataModal
        isOpen={showImportModal}
        onClose={() => setShowImportModal(false)}
      />

      {/* About */}
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
        <h2 className="text-xl font-semibold mb-4 text-gray-900 dark:text-white">About</h2>
        <div className="space-y-2 text-sm text-gray-600 dark:text-gray-400">
          <p>Danielle's Money Tracker v1.0</p>
          <p>A personal finance management application</p>
          <p className="flex items-center gap-2">
            <Palette size={16} />
            Built with React, TypeScript, and Tailwind CSS
          </p>
        </div>
      </div>
    </div>
  );
}


=== src/pages/Transactions.tsx ===
import { useState } from 'react';
import { useApp } from '../contexts/AppContext';
import { usePreferences } from '../contexts/PreferencesContext';
import AddTransactionModal from '../components/AddTransactionModal';
import { Plus, TrendingUp, TrendingDown, Filter, Calendar, Trash2, Minimize2, Maximize2 } from 'lucide-react';

export default function Transactions() {
  const { transactions, accounts, deleteTransaction } = useApp();
  const { compactView, setCompactView } = usePreferences();
  const [isAddModalOpen, setIsAddModalOpen] = useState(false);
  const [filterType, setFilterType] = useState<'all' | 'income' | 'expense'>('all');
  const [filterAccountId, setFilterAccountId] = useState<string>('');

  // Helper function to format currency properly
  const formatCurrency = (amount: number, currency: string = 'GBP'): string => {
    const symbol = currency === 'GBP' ? '£' : currency === 'USD' ? '$' : '€';
    return symbol + new Intl.NumberFormat('en-GB', {
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    }).format(Math.abs(amount));
  };

  // Sort transactions by date (newest first)
  const sortedTransactions = [...transactions].sort((a, b) => 
    new Date(b.date).getTime() - new Date(a.date).getTime()
  );

  // Apply filters
  const filteredTransactions = sortedTransactions.filter(transaction => {
    if (filterType !== 'all' && transaction.type !== filterType) return false;
    if (filterAccountId && transaction.accountId !== filterAccountId) return false;
    return true;
  });

  const getTypeIcon = (type: string) => {
    return type === 'income' ? (
      <TrendingUp className="text-green-500" size={compactView ? 16 : 20} />
    ) : (
      <TrendingDown className="text-red-500" size={compactView ? 16 : 20} />
    );
  };

  const handleDelete = (id: string) => {
    if (window.confirm('Are you sure you want to delete this transaction?')) {
      deleteTransaction(id);
    }
  };

  // Calculate totals
  const totals = filteredTransactions.reduce((acc, t) => {
    if (t.type === 'income') acc.income += t.amount;
    else if (t.type === 'expense') acc.expense += t.amount;
    return acc;
  }, { income: 0, expense: 0 });

  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-gray-900 dark:text-white">Transactions</h1>
        <div className="flex items-center gap-2">
          {/* Compact View Toggle */}
          <button
            onClick={() => setCompactView(!compactView)}
            className="flex items-center gap-2 px-3 py-2 text-sm border border-gray-300 dark:border-gray-600 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors"
            title={compactView ? "Switch to normal view" : "Switch to compact view"}
          >
            {compactView ? <Maximize2 size={16} /> : <Minimize2 size={16} />}
            <span className="hidden sm:inline dark:text-white">
              {compactView ? 'Normal View' : 'Compact View'}
            </span>
          </button>
          
          <button 
            onClick={() => setIsAddModalOpen(true)}
            className="bg-primary text-white px-4 py-2 rounded-lg hover:bg-secondary transition-colors flex items-center gap-2"
          >
            <Plus size={20} />
            <span className="hidden sm:inline">Add Transaction</span>
          </button>
        </div>
      </div>

      {/* Summary Cards */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
        <div className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow">
          <div className="flex items-center justify-between">
            <div>
              <p className="text-sm text-gray-500 dark:text-gray-400">Income</p>
              <p className="text-xl font-bold text-green-600 dark:text-green-400">{formatCurrency(totals.income)}</p>
            </div>
            <TrendingUp className="text-green-500" size={24} />
          </div>
        </div>
        <div className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow">
          <div className="flex items-center justify-between">
            <div>
              <p className="text-sm text-gray-500 dark:text-gray-400">Expenses</p>
              <p className="text-xl font-bold text-red-600 dark:text-red-400">{formatCurrency(totals.expense)}</p>
            </div>
            <TrendingDown className="text-red-500" size={24} />
          </div>
        </div>
        <div className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow">
          <div className="flex items-center justify-between">
            <div>
              <p className="text-sm text-gray-500 dark:text-gray-400">Net</p>
              <p className={`text-xl font-bold ${totals.income - totals.expense >= 0 ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'}`}>
                {formatCurrency(totals.income - totals.expense)}
              </p>
            </div>
            <Calendar className="text-primary" size={24} />
          </div>
        </div>
      </div>

      {/* Filters */}
      <div className="bg-white dark:bg-gray-800 p-4 rounded-lg shadow mb-6">
        <div className="flex flex-wrap gap-4">
          <div className="flex items-center gap-2">
            <Filter size={20} className="text-gray-500 dark:text-gray-400" />
            <select
              className="px-3 py-1 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-primary"
              value={filterType}
              onChange={(e) => setFilterType(e.target.value as any)}
            >
              <option value="all">All Types</option>
              <option value="income">Income Only</option>
              <option value="expense">Expenses Only</option>
            </select>
          </div>
          <div>
            <select
              className="px-3 py-1 border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white rounded-lg focus:outline-none focus:ring-2 focus:ring-primary"
              value={filterAccountId}
              onChange={(e) => setFilterAccountId(e.target.value)}
            >
              <option value="">All Accounts</option>
              {accounts.map(account => (
                <option key={account.id} value={account.id}>{account.name}</option>
              ))}
            </select>
          </div>
        </div>
      </div>

      {/* Transactions List */}
      {filteredTransactions.length === 0 ? (
        <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
          <p className="text-gray-500 dark:text-gray-400 text-center py-8">
            {transactions.length === 0 
              ? "No transactions yet. Click 'Add Transaction' to record your first one!"
              : "No transactions match your filters."}
          </p>
        </div>
      ) : (
        <div className="bg-white dark:bg-gray-800 rounded-lg shadow overflow-hidden">
          <div className="overflow-x-auto">
            <table className="w-full">
              <thead className="bg-gray-50 dark:bg-gray-700">
                <tr>
                  <th className={`px-6 ${compactView ? 'py-2' : 'py-3'} text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider`}>
                    Date
                  </th>
                  <th className={`px-6 ${compactView ? 'py-2' : 'py-3'} text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider`}>
                    Description
                  </th>
                  <th className={`px-6 ${compactView ? 'py-2' : 'py-3'} text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider hidden sm:table-cell`}>
                    Category
                  </th>
                  <th className={`px-6 ${compactView ? 'py-2' : 'py-3'} text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider hidden md:table-cell`}>
                    Account
                  </th>
                  <th className={`px-6 ${compactView ? 'py-2' : 'py-3'} text-right text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider`}>
                    Amount
                  </th>
                  <th className={`px-6 ${compactView ? 'py-2' : 'py-3'} text-right text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider`}>
                    Actions
                  </th>
                </tr>
              </thead>
              <tbody className="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">
                {filteredTransactions.map((transaction) => {
                  const account = accounts.find(a => a.id === transaction.accountId);
                  return (
                    <tr key={transaction.id} className="hover:bg-gray-50 dark:hover:bg-gray-700">
                      <td className={`px-6 ${compactView ? 'py-2' : 'py-4'} whitespace-nowrap text-sm text-gray-900 dark:text-gray-100`}>
                        {new Date(transaction.date).toLocaleDateString()}
                      </td>
                      <td className={`px-6 ${compactView ? 'py-2' : 'py-4'} whitespace-nowrap`}>
                        <div className="flex items-center gap-2">
                          {getTypeIcon(transaction.type)}
                          <span className={`${compactView ? 'text-sm' : 'text-sm'} text-gray-900 dark:text-gray-100`}>{transaction.description}</span>
                        </div>
                      </td>
                      <td className={`px-6 ${compactView ? 'py-2' : 'py-4'} whitespace-nowrap text-sm text-gray-500 dark:text-gray-400 hidden sm:table-cell`}>
                        {transaction.category}
                      </td>
                      <td className={`px-6 ${compactView ? 'py-2' : 'py-4'} whitespace-nowrap text-sm text-gray-500 dark:text-gray-400 hidden md:table-cell`}>
                        {account?.name || 'Unknown'}
                      </td>
                      <td className={`px-6 ${compactView ? 'py-2' : 'py-4'} whitespace-nowrap text-sm text-right font-medium ${
                        transaction.type === 'income' ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'
                      }`}>
                        {transaction.type === 'income' ? '+' : '-'}
                        {formatCurrency(transaction.amount, account?.currency || 'GBP')}
                      </td>
                      <td className={`px-6 ${compactView ? 'py-2' : 'py-4'} whitespace-nowrap text-right text-sm font-medium`}>
                        <button
                          onClick={() => handleDelete(transaction.id)}
                          className="text-red-600 dark:text-red-400 hover:text-red-900 dark:hover:text-red-300"
                        >
                          <Trash2 size={16} />
                        </button>
                      </td>
                    </tr>
                  );
                })}
              </tbody>
            </table>
          </div>
        </div>
      )}

      <AddTransactionModal 
        isOpen={isAddModalOpen} 
        onClose={() => setIsAddModalOpen(false)} 
      />
    </div>
  );
}



=== src/types/index.ts ===
export interface Account {
  id: string;
  name: string;
  type: 'checking' | 'savings' | 'credit' | 'loan' | 'investment';
  balance: number;
  currency: string;
  institution: string;
  lastUpdated: Date;
}

export interface Transaction {
  id: string;
  date: Date;
  amount: number;
  description: string;
  category: string;
  accountId: string;
  type: 'income' | 'expense';
}

export interface Budget {
  id: string;
  category: string;
  amount: number;
  period: 'monthly' | 'weekly' | 'yearly';
  isActive: boolean;
  createdAt: Date;
}


=== src/utils/formatters.ts ===
export function formatCurrency(amount: number, currency: string = 'GBP'): string {
  const symbol = currency === 'GBP' ? '£' : currency === 'USD' ? '$' : '€';
  const absAmount = Math.abs(amount);
  const formatted = absAmount.toLocaleString('en-GB', {
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  });
  return `${symbol}${formatted}`;
}

export function formatNumber(num: number): string {
  return num.toLocaleString('en-GB', {
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  });
}

export function formatCompactNumber(num: number): string {
  if (num >= 1000000) {
    return `${(num / 1000000).toFixed(1)}M`;
  } else if (num >= 1000) {
    return `${(num / 1000).toFixed(1)}K`;
  }
  return formatNumber(num);
}


=== src/utils/generateTestData.ts ===
export function generateTestData() {
  const today = new Date();
  
  // Helper function for date manipulation
  function subDaysFromDate(date: Date, days: number): Date {
    const result = new Date(date);
    result.setDate(result.getDate() - days);
    return result;
  }

  // Test Accounts - More variety
  const accounts = [
    // Bank Accounts
    {
      id: 'acc1',
      name: 'Barclays Current Account',
      type: 'checking' as const,
      balance: 3567.89,
      currency: 'GBP',
      institution: 'Barclays',
      lastUpdated: today,
    },
    {
      id: 'acc2',
      name: 'Halifax Savings',
      type: 'savings' as const,
      balance: 12750.00,
      currency: 'GBP',
      institution: 'Halifax',
      lastUpdated: today,
    },
    {
      id: 'acc3',
      name: 'HSBC Joint Account',
      type: 'checking' as const,
      balance: 1234.56,
      currency: 'GBP',
      institution: 'HSBC',
      lastUpdated: today,
    },
    {
      id: 'acc4',
      name: 'Marcus Savings',
      type: 'savings' as const,
      balance: 25000.00,
      currency: 'GBP',
      institution: 'Marcus by Goldman Sachs',
      lastUpdated: today,
    },
    
    // Credit Cards
    {
      id: 'acc5',
      name: 'Amex Platinum',
      type: 'credit' as const,
      balance: -2345.67,
      currency: 'GBP',
      institution: 'American Express',
      lastUpdated: today,
    },
    {
      id: 'acc6',
      name: 'Barclaycard Rewards',
      type: 'credit' as const,
      balance: -567.89,
      currency: 'GBP',
      institution: 'Barclays',
      lastUpdated: today,
    },
    
    // Loans
    {
      id: 'acc7',
      name: 'Mortgage - Home',
      type: 'loan' as const,
      balance: -187500.00,
      currency: 'GBP',
      institution: 'Nationwide',
      lastUpdated: today,
    },
    {
      id: 'acc8',
      name: 'Car Finance - Tesla Model 3',
      type: 'loan' as const,
      balance: -22750.00,
      currency: 'GBP',
      institution: 'Tesla Finance',
      lastUpdated: today,
    },
    {
      id: 'acc9',
      name: 'Student Loan',
      type: 'loan' as const,
      balance: -28500.00,
      currency: 'GBP',
      institution: 'Student Loans Company',
      lastUpdated: today,
    },
    
    // UK Investments
    {
      id: 'acc10',
      name: 'Vanguard ISA',
      type: 'investment' as const,
      balance: 15670.50,
      currency: 'GBP',
      institution: 'Vanguard',
      lastUpdated: today,
    },
    {
      id: 'acc11',
      name: 'Hargreaves Lansdown SIPP',
      type: 'investment' as const,
      balance: 45230.75,
      currency: 'GBP',
      institution: 'Hargreaves Lansdown',
      lastUpdated: today,
    },
    {
      id: 'acc12',
      name: 'Trading 212 - UK Stocks',
      type: 'investment' as const,
      balance: 3456.78,
      currency: 'GBP',
      institution: 'Trading 212',
      lastUpdated: today,
    },
    
    // US Investments
    {
      id: 'acc13',
      name: 'Robinhood - US Stocks',
      type: 'investment' as const,
      balance: 5234.00,
      currency: 'USD',
      institution: 'Robinhood',
      lastUpdated: today,
    },
    {
      id: 'acc14',
      name: 'E*TRADE Portfolio',
      type: 'investment' as const,
      balance: 12500.00,
      currency: 'USD',
      institution: 'E*TRADE',
      lastUpdated: today,
    },
    
    // Crypto (as investment)
    {
      id: 'acc15',
      name: 'Coinbase Crypto',
      type: 'investment' as const,
      balance: 2890.45,
      currency: 'GBP',
      institution: 'Coinbase',
      lastUpdated: today,
    },
  ];

  // Generate transactions for the last 60 days
  const transactions = [];
  let transactionId = 1;

  // Recurring transactions
  const recurringTransactions = [
    // Income
    { description: 'Salary - Main Job', amount: 3850, type: 'income' as const, category: 'Salary', accountId: 'acc1', dayOfMonth: 28 },
    { description: 'Freelance Income', amount: 750, type: 'income' as const, category: 'Freelance', accountId: 'acc1', dayOfMonth: 15 },
    
    // Housing
    { description: 'Mortgage Payment', amount: 1450, type: 'expense' as const, category: 'Bills', accountId: 'acc3', dayOfMonth: 1 },
    { description: 'Council Tax', amount: 156, type: 'expense' as const, category: 'Bills', accountId: 'acc3', dayOfMonth: 5 },
    { description: 'Gas & Electric', amount: 125, type: 'expense' as const, category: 'Bills', accountId: 'acc3', dayOfMonth: 15 },
    { description: 'Water Bill', amount: 35, type: 'expense' as const, category: 'Bills', accountId: 'acc3', dayOfMonth: 20 },
    { description: 'Internet - BT Fibre', amount: 49.99, type: 'expense' as const, category: 'Bills', accountId: 'acc1', dayOfMonth: 12 },
    
    // Transport
    { description: 'Car Finance - Tesla', amount: 425, type: 'expense' as const, category: 'Transport', accountId: 'acc1', dayOfMonth: 10 },
    { description: 'Car Insurance', amount: 89, type: 'expense' as const, category: 'Transport', accountId: 'acc1', dayOfMonth: 8 },
    
    // Subscriptions
    { description: 'Mobile Phone - EE', amount: 45, type: 'expense' as const, category: 'Bills', accountId: 'acc1', dayOfMonth: 22 },
    { description: 'Gym - PureGym', amount: 24.99, type: 'expense' as const, category: 'Healthcare', accountId: 'acc5', dayOfMonth: 5 },
    { description: 'Netflix', amount: 15.99, type: 'expense' as const, category: 'Entertainment', accountId: 'acc5', dayOfMonth: 8 },
    { description: 'Spotify Premium', amount: 10.99, type: 'expense' as const, category: 'Entertainment', accountId: 'acc5', dayOfMonth: 12 },
    
    // Investments
    { description: 'Vanguard ISA - Monthly', amount: 500, type: 'expense' as const, category: 'Investment', accountId: 'acc1', dayOfMonth: 1 },
    { description: 'Pension Contribution', amount: 300, type: 'expense' as const, category: 'Investment', accountId: 'acc1', dayOfMonth: 28 },
  ];

  // Random transactions
  const randomExpenses = [
    // UK Shops
    { description: 'Tesco Metro', category: 'Food & Dining', min: 15, max: 80 },
    { description: 'Sainsbury\'s Local', category: 'Food & Dining', min: 10, max: 60 },
    { description: 'Waitrose', category: 'Food & Dining', min: 25, max: 100 },
    { description: 'ASDA', category: 'Food & Dining', min: 30, max: 120 },
    { description: 'M&S Food', category: 'Food & Dining', min: 15, max: 50 },
    
    // Coffee & Dining
    { description: 'Pret A Manger', category: 'Food & Dining', min: 4, max: 12 },
    { description: 'Costa Coffee', category: 'Food & Dining', min: 3, max: 8 },
    { description: 'Starbucks', category: 'Food & Dining', min: 4, max: 10 },
    { description: 'Nando\'s', category: 'Food & Dining', min: 15, max: 35 },
    { description: 'Pizza Express', category: 'Food & Dining', min: 25, max: 60 },
    { description: 'Dishoom', category: 'Food & Dining', min: 30, max: 80 },
    
    // Shopping
    { description: 'Amazon UK', category: 'Shopping', min: 10, max: 150 },
    { description: 'John Lewis', category: 'Shopping', min: 30, max: 200 },
    { description: 'Next', category: 'Shopping', min: 25, max: 100 },
    { description: 'Zara', category: 'Shopping', min: 20, max: 80 },
    { description: 'Boots', category: 'Healthcare', min: 5, max: 40 },
    { description: 'Waterstones', category: 'Shopping', min: 10, max: 30 },
    
    // Transport
    { description: 'Shell Petrol', category: 'Transport', min: 40, max: 70 },
    { description: 'BP Fuel', category: 'Transport', min: 45, max: 75 },
    { description: 'TfL - Oyster Card', category: 'Transport', min: 5, max: 20 },
    { description: 'Uber', category: 'Transport', min: 8, max: 25 },
    { description: 'National Rail', category: 'Transport', min: 15, max: 50 },
    
    // Entertainment
    { description: 'Vue Cinema', category: 'Entertainment', min: 10, max: 25 },
    { description: 'Steam Games', category: 'Entertainment', min: 5, max: 40 },
    { description: 'The Gym Group', category: 'Healthcare', min: 3, max: 10 },
  ];

  // Generate transactions for last 60 days
  for (let daysAgo = 60; daysAgo >= 0; daysAgo--) {
    const currentDate = subDaysFromDate(today, daysAgo);
    const dayOfMonth = currentDate.getDate();

    // Add recurring transactions
    recurringTransactions.forEach(recurring => {
      if (dayOfMonth === recurring.dayOfMonth) {
        transactions.push({
          id: `trans${transactionId++}`,
          accountId: recurring.accountId,
          date: currentDate,
          description: recurring.description,
          amount: recurring.amount,
          type: recurring.type,
          category: recurring.category,
        });
      }
    });

    // Add 1-4 random transactions per day
    const numRandomTransactions = Math.floor(Math.random() * 4) + 1;
    for (let i = 0; i < numRandomTransactions; i++) {
      const expense = randomExpenses[Math.floor(Math.random() * randomExpenses.length)];
      const amount = expense.min + Math.random() * (expense.max - expense.min);
      
      // Mix between accounts - 50% checking, 30% joint, 20% credit cards
      let accountId = 'acc1';
      const accountChoice = Math.random();
      if (accountChoice < 0.5) {
        accountId = 'acc1'; // Main checking
      } else if (accountChoice < 0.8) {
        accountId = 'acc3'; // Joint account
      } else if (accountChoice < 0.9) {
        accountId = 'acc5'; // Amex
      } else {
        accountId = 'acc6'; // Barclaycard
      }
      
      transactions.push({
        id: `trans${transactionId++}`,
        accountId: accountId,
        date: currentDate,
        description: expense.description,
        amount: Number(amount.toFixed(2)),
        type: 'expense' as const,
        category: expense.category,
      });
    }
  }

  // Add some investment transactions
  const investmentTransactions = [
    // UK Stocks
    { accountId: 'acc12', description: 'Bought Rolls-Royce shares', amount: 500, date: subDaysFromDate(today, 45) },
    { accountId: 'acc12', description: 'Bought BP shares', amount: 300, date: subDaysFromDate(today, 38) },
    { accountId: 'acc12', description: 'Bought Lloyds shares', amount: 250, date: subDaysFromDate(today, 30) },
    { accountId: 'acc10', description: 'Dividend - FTSE All-Share', amount: 125.50, date: subDaysFromDate(today, 25), type: 'income' },
    
    // US Stocks
    { accountId: 'acc13', description: 'Bought Apple shares', amount: 1000, date: subDaysFromDate(today, 40) },
    { accountId: 'acc13', description: 'Bought Microsoft shares', amount: 750, date: subDaysFromDate(today, 35) },
    { accountId: 'acc13', description: 'Bought Tesla shares', amount: 500, date: subDaysFromDate(today, 28) },
    { accountId: 'acc14', description: 'Bought Amazon shares', amount: 1500, date: subDaysFromDate(today, 20) },
    { accountId: 'acc14', description: 'Dividend - S&P 500 ETF', amount: 85.25, date: subDaysFromDate(today, 15), type: 'income' },
    
    // Crypto
    { accountId: 'acc15', description: 'Bought Bitcoin', amount: 500, date: subDaysFromDate(today, 22) },
    { accountId: 'acc15', description: 'Bought Ethereum', amount: 300, date: subDaysFromDate(today, 18) },
  ];

  investmentTransactions.forEach(inv => {
    transactions.push({
      id: `trans${transactionId++}`,
      accountId: inv.accountId,
      date: inv.date,
      description: inv.description,
      amount: inv.amount,
      type: (inv.type || 'expense') as 'income' | 'expense',
      category: 'Investment',
    });
  });

  // Add some loan payments that aren't recurring
  transactions.push(
    {
      id: `trans${transactionId++}`,
      accountId: 'acc1',
      date: subDaysFromDate(today, 50),
      description: 'Student Loan - Extra Payment',
      amount: 200,
      type: 'expense' as const,
      category: 'Bills',
    },
    {
      id: `trans${transactionId++}`,
      accountId: 'acc2',
      date: subDaysFromDate(today, 15),
      description: 'Interest Earned',
      amount: 45.83,
      type: 'income' as const,
      category: 'Investment',
    },
    {
      id: `trans${transactionId++}`,
      accountId: 'acc4',
      date: subDaysFromDate(today, 10),
      description: 'Marcus Interest',
      amount: 89.58,
      type: 'income' as const,
      category: 'Investment',
    }
  );

  // Test Budgets
  const budgets = [
    {
      id: 'budget1',
      category: 'Food & Dining',
      amount: 600,
      period: 'monthly' as const,
      isActive: true,
      createdAt: today,
    },
    {
      id: 'budget2',
      category: 'Shopping',
      amount: 400,
      period: 'monthly' as const,
      isActive: true,
      createdAt: today,
    },
    {
      id: 'budget3',
      category: 'Transport',
      amount: 250,
      period: 'monthly' as const,
      isActive: true,
      createdAt: today,
    },
    {
      id: 'budget4',
      category: 'Entertainment',
      amount: 150,
      period: 'monthly' as const,
      isActive: true,
      createdAt: today,
    },
    {
      id: 'budget5',
      category: 'Bills',
      amount: 2200,
      period: 'monthly' as const,
      isActive: true,
      createdAt: today,
    },
    {
      id: 'budget6',
      category: 'Healthcare',
      amount: 100,
      period: 'monthly' as const,
      isActive: true,
      createdAt: today,
    },
    {
      id: 'budget7',
      category: 'Investment',
      amount: 800,
      period: 'monthly' as const,
      isActive: true,
      createdAt: today,
    },
  ];

  return { accounts, transactions, budgets };
}


=== src/utils/initializeApp.ts ===
import { generateTestData } from './generateTestData';

export function initializeAppData() {
  try {
    // Check if localStorage is available
    if (typeof Storage === 'undefined') {
      console.error('LocalStorage not available');
      return generateTestData();
    }
    
    // Check for existing data
    const hasAccounts = localStorage.getItem('wealthtracker_accounts');
    const hasTransactions = localStorage.getItem('wealthtracker_transactions');
    const hasBudgets = localStorage.getItem('wealthtracker_budgets');
    
    // If no data exists, generate test data
    if (!hasAccounts && !hasTransactions && !hasBudgets) {
      console.log('No existing data found, generating test data...');
      const testData = generateTestData();
      
      // Save to localStorage with error handling
      try {
        localStorage.setItem('wealthtracker_accounts', JSON.stringify(testData.accounts));
        localStorage.setItem('wealthtracker_transactions', JSON.stringify(testData.transactions));
        localStorage.setItem('wealthtracker_budgets', JSON.stringify(testData.budgets));
        
        // Force default preferences on first load
        if (!localStorage.getItem('money_management_theme')) {
          localStorage.setItem('money_management_theme', 'dark');
        }
        if (!localStorage.getItem('money_management_accent_color')) {
          localStorage.setItem('money_management_accent_color', 'pink');
        }
      } catch (e) {
        console.error('Error saving to localStorage:', e);
      }
      
      return testData;
    }
    
    // Load existing data
    return {
      accounts: hasAccounts ? JSON.parse(hasAccounts) : [],
      transactions: hasTransactions ? JSON.parse(hasTransactions) : [],
      budgets: hasBudgets ? JSON.parse(hasBudgets) : []
    };
  } catch (error) {
    console.error('Error initializing app data:', error);
    return generateTestData();
  }
}


=== src/utils/mbfParser.ts ===
// Microsoft Money .mny file parser
// .mny files are the active database files used by Microsoft Money

export interface ParsedAccount {
  name: string;
  type: 'checking' | 'savings' | 'credit' | 'loan' | 'investment';
  balance: number;
  accountNumber?: string;
}

export interface ParsedTransaction {
  date: Date;
  amount: number;
  description: string;
  type: 'income' | 'expense';
  category: string;
  payee?: string;
  accountName?: string;
}

export async function parseMNY(arrayBuffer: ArrayBuffer): Promise<{
  accounts: ParsedAccount[];
  transactions: ParsedTransaction[];
}> {
  const dataView = new DataView(arrayBuffer);
  const uint8Array = new Uint8Array(arrayBuffer);
  const transactions: ParsedTransaction[] = [];
  const accountsMap = new Map<string, ParsedAccount>();
  
  console.log('Parsing Microsoft Money .mny file, size:', arrayBuffer.byteLength);
  
  try {
    // .mny files are actually Microsoft Jet database files (Access format)
    // They typically start with specific headers
    
    // Check for Jet database signature
    const signature = Array.from(uint8Array.slice(0, 16)).map(b => b.toString(16).padStart(2, '0')).join(' ');
    console.log('File signature:', signature);
    
    // Helper to read null-terminated strings
    const readString = (offset: number, maxLength: number = 255): string => {
      let str = '';
      for (let i = 0; i < maxLength && offset + i < uint8Array.length; i++) {
        const byte = uint8Array[offset + i];
        if (byte === 0) break;
        if (byte >= 32 && byte <= 126) {
          str += String.fromCharCode(byte);
        }
      }
      return str;
    };

    // Helper to read Unicode strings (UTF-16 LE)
    const readUnicodeString = (offset: number, maxLength: number = 255): string => {
      let str = '';
      for (let i = 0; i < maxLength && offset + i * 2 + 1 < uint8Array.length; i++) {
        const charCode = uint8Array[offset + i * 2] | (uint8Array[offset + i * 2 + 1] << 8);
        if (charCode === 0) break;
        str += String.fromCharCode(charCode);
      }
      return str;
    };

    // Look for table definitions in Jet database
    // Money stores data in tables like ACCT (accounts), TRNS (transactions), etc.
    
    // Search for ACCT table pattern
    const acctPatterns = [
      'ACCT',
      'Account',
      'tblAccount',
      'AccountTable'
    ];
    
    for (const pattern of acctPatterns) {
      const patternBytes = Array.from(pattern).map(c => c.charCodeAt(0));
      
      for (let i = 0; i < uint8Array.length - pattern.length - 200; i++) {
        let found = true;
        for (let j = 0; j < patternBytes.length; j++) {
          if (uint8Array[i + j] !== patternBytes[j]) {
            found = false;
            break;
          }
        }
        
        if (found) {
          console.log(`Found ${pattern} at offset ${i}`);
          
          // Look for account data near this pattern
          for (let offset = i + pattern.length; offset < i + 1000 && offset < uint8Array.length - 100; offset++) {
            // Try to read account name
            const accountName = readString(offset) || readUnicodeString(offset);
            
            if (accountName && accountName.length > 2 && accountName.length < 50 && 
                !accountName.includes('ACCT') && !accountName.includes('\\')) {
              
              // Look for account type indicators
              let accountType: ParsedAccount['type'] = 'checking';
              const nearbyText = readString(offset - 50, 200).toLowerCase() + 
                               readString(offset + 50, 200).toLowerCase();
              
              if (nearbyText.includes('credit') || nearbyText.includes('card')) {
                accountType = 'credit';
              } else if (nearbyText.includes('saving')) {
                accountType = 'savings';
              } else if (nearbyText.includes('loan') || nearbyText.includes('mortgage')) {
                accountType = 'loan';
              } else if (nearbyText.includes('invest') || nearbyText.includes('brokerage')) {
                accountType = 'investment';
              }
              
              if (!accountsMap.has(accountName)) {
                accountsMap.set(accountName, {
                  name: accountName,
                  type: accountType,
                  balance: 0
                });
                console.log('Found account:', accountName, 'Type:', accountType);
              }
            }
          }
        }
      }
    }

    // Money uses various date formats
    const parseMoneyDate = (_arrayBuffer: ArrayBuffer, offset: number): Date | null => {
      // Try different date formats
      
      // Format 1: Days since 1900 (4 bytes)
      const days1900 = dataView.getInt32(offset, true);
      if (days1900 > 20000 && days1900 < 60000) {
        const date = new Date(1900, 0, 1);
        date.setDate(date.getDate() + days1900);
        if (date.getFullYear() >= 1990 && date.getFullYear() <= 2030) {
          return date;
        }
      }
      
      // Format 2: OLE Automation date (8 bytes double)
      const oleDate = dataView.getFloat64(offset, true);
      if (oleDate > 30000 && oleDate < 50000) {
        const date = new Date((oleDate - 25569) * 86400 * 1000);
        if (date.getFullYear() >= 1990 && date.getFullYear() <= 2030) {
          return date;
        }
      }
      
      // Format 3: Unix timestamp (4 bytes)
      const unixTime = dataView.getUint32(offset, true);
      if (unixTime > 946684800 && unixTime < 2147483647) { // Between 2000 and 2038
        return new Date(unixTime * 1000);
      }
      
      return null;
    };
    
    // Scan for transaction-like data structures
    for (let i = 0; i < uint8Array.length - 200; i++) {
      // Look for potential date values
      const date = parseMoneyDate(arrayBuffer, i);
      
      if (date) {
        // Found a valid date, look for amount nearby
        for (let j = 4; j <= 50; j += 4) {
          if (i + j + 8 > uint8Array.length) break;
          
          // Try reading as currency (could be int cents or float dollars)
          const amountCents = dataView.getInt32(i + j, true);
          const amountFloat = dataView.getFloat64(i + j, true);
          
          let amount = 0;
          if (Math.abs(amountCents) > 0 && Math.abs(amountCents) < 10000000) {
            amount = amountCents / 100;
          } else if (Math.abs(amountFloat) > 0.01 && Math.abs(amountFloat) < 1000000) {
            amount = amountFloat;
          }
          
          if (amount !== 0) {
            // Look for description/payee
            let description = '';
            let payee = '';
            
            // Search forward for text
            for (let k = j + 8; k < j + 200 && i + k < uint8Array.length; k++) {
              const str = readString(i + k) || readUnicodeString(i + k);
              if (str && str.length > 2 && str.length < 100) {
                if (!description) {
                  description = str;
                } else if (!payee) {
                  payee = str;
                  break;
                }
              }
            }
            
            if (description) {
              transactions.push({
                date: date,
                amount: Math.abs(amount),
                description: description,
                type: amount < 0 ? 'expense' : 'income',
                category: 'Imported',
                payee: payee || undefined
              });
              
              i += j + 100; // Skip past this transaction
              break;
            }
          }
        }
      }
    }

    // Additional pattern: Look for transaction blocks with specific markers
    for (let i = 0; i < uint8Array.length - 500; i++) {
      // Money sometimes uses record markers like 0x00 0x00 followed by record length
      if (uint8Array[i] === 0x00 && uint8Array[i + 1] === 0x00) {
        const recordLength = dataView.getUint16(i + 2, true);
        
        if (recordLength > 20 && recordLength < 500) {
          // Potential transaction record
          let foundDate = false;
          let foundAmount = false;
          let transDate: Date | null = null;
          let transAmount = 0;
          let transDesc = '';
          
          // Scan the record for date and amount
          for (let j = 4; j < recordLength - 8 && i + j + 8 < uint8Array.length; j += 4) {
            if (!foundDate) {
              transDate = parseMoneyDate(arrayBuffer, i + j);
              if (transDate) foundDate = true;
            }
            
            if (!foundAmount && foundDate) {
              const possibleAmount = dataView.getInt32(i + j, true);
              if (Math.abs(possibleAmount) > 100 && Math.abs(possibleAmount) < 10000000) {
                transAmount = possibleAmount / 100;
                foundAmount = true;
                
                // Look for description after amount
                for (let k = j + 4; k < recordLength && i + k < uint8Array.length; k++) {
                  const str = readString(i + k) || readUnicodeString(i + k);
                  if (str && str.length > 2) {
                    transDesc = str;
                    break;
                  }
                }
              }
            }
            
            if (foundDate && foundAmount && transDesc) break;
          }
          
          if (foundDate && foundAmount && transDesc && transDate) {
            transactions.push({
              date: transDate,
              amount: Math.abs(transAmount),
              description: transDesc,
              type: transAmount < 0 ? 'expense' : 'income',
              category: 'Imported'
            });
          }
        }
      }
    }

    // If no accounts found, create a default
    if (accountsMap.size === 0) {
      console.log('No accounts found, creating default');
      accountsMap.set('Money Import', {
        name: 'Money Import',
        type: 'checking',
        balance: 0
      });
    }

    // Remove duplicate transactions
    const uniqueTransactions = transactions.filter((trans, index, self) =>
      index === self.findIndex((t) => (
        Math.abs(t.date.getTime() - trans.date.getTime()) < 86400000 && // Same day
        Math.abs(t.amount - trans.amount) < 0.01 &&
        t.description === trans.description
      ))
    );

    // Sort by date
    uniqueTransactions.sort((a, b) => a.date.getTime() - b.date.getTime());

    console.log(`Parsed ${accountsMap.size} accounts and ${uniqueTransactions.length} transactions`);
    
    return {
      accounts: Array.from(accountsMap.values()),
      transactions: uniqueTransactions
    };
    
  } catch (error) {
    console.error('Error parsing .mny file:', error);
    throw new Error('Failed to parse Microsoft Money file. The file may be encrypted, corrupted, or in an unsupported version.');
  }
}

=== src/utils/mnyParser.ts ===
// Microsoft Money .mny file parser with manual mapping support

export interface ParsedAccount {
  name: string;
  type: 'checking' | 'savings' | 'credit' | 'loan' | 'investment';
  balance: number;
  accountNumber?: string;
}

export interface ParsedTransaction {
  date: Date;
  amount: number;
  description: string;
  type: 'income' | 'expense';
  category: string;
  payee?: string;
  accountName?: string;
}

export interface ParseResult {
  accounts: ParsedAccount[];
  transactions: ParsedTransaction[];
  warning?: string;
  rawData?: any[];
  needsMapping?: boolean;
}

export async function parseMNY(arrayBuffer: ArrayBuffer): Promise<ParseResult> {
  const uint8Array = new Uint8Array(arrayBuffer);
  const dataView = new DataView(arrayBuffer);
  
  console.log('Parsing Microsoft Money .mny file, size:', arrayBuffer.byteLength);
  
  // Try to extract structured data that could be transactions
  const potentialRecords: any[] = [];
  const recordSize = 256; // Guess at record size
  const maxRecords = 10000;
  
  // Strategy: Look for patterns that might be structured records
  // We'll extract data and let the user tell us what it means
  
  for (let offset = 0; offset < arrayBuffer.byteLength - recordSize && potentialRecords.length < maxRecords; offset += recordSize) {
    const record: any = {};
    
    // Try to read various data types at different offsets
    for (let i = 0; i < Math.min(10, recordSize / 8); i++) {
      const pos = offset + i * 8;
      
      if (pos + 8 <= arrayBuffer.byteLength) {
        // Try reading as double (8 bytes)
        const doubleValue = dataView.getFloat64(pos, true);
        
        // Check if it might be an OLE date
        if (doubleValue > 30000 && doubleValue < 60000) {
          record[`field_${i}_date`] = doubleValue;
        }
        // Check if it might be a currency amount
        else if (Math.abs(doubleValue) > 0.01 && Math.abs(doubleValue) < 1000000) {
          record[`field_${i}_amount`] = doubleValue;
        }
        
        // Try reading as 32-bit integer
        const intValue = dataView.getInt32(pos, true);
        if (intValue > 0 && intValue < 1000000) {
          record[`field_${i}_int`] = intValue;
        }
      }
      
      // Try reading as string (both ASCII and UTF-16)
      const asciiStr = readString(uint8Array, offset + i * 20, 50);
      if (asciiStr && asciiStr.length > 2) {
        record[`field_${i}_text`] = asciiStr;
      }
      
      const utf16Str = readUTF16String(uint8Array, offset + i * 20, 25);
      if (utf16Str && utf16Str.length > 2 && utf16Str !== asciiStr) {
        record[`field_${i}_text_utf16`] = utf16Str;
      }
    }
    
    // Only add records that have at least some meaningful data
    if (Object.keys(record).length >= 3) {
      potentialRecords.push(record);
    }
    
    // Progress
    if (offset % (1024 * 1024) === 0 && offset > 0) {
      console.log(`Scanned ${(offset / (1024 * 1024)).toFixed(1)}MB...`);
      await new Promise(resolve => setTimeout(resolve, 0));
    }
  }
  
  console.log(`Extracted ${potentialRecords.length} potential records`);
  
  if (potentialRecords.length > 10) {
    // We found structured data - let user map it
    return {
      accounts: [],
      transactions: [],
      rawData: potentialRecords,
      needsMapping: true,
      warning: 'We found structured data in your Money file. Please help us understand what each field represents.'
    };
  }
  
  // Fallback if we can't find structured data
  return {
    accounts: [{
      name: 'Money Import',
      type: 'checking',
      balance: 0
    }],
    transactions: [],
    warning: 'Unable to automatically parse this Money file. Please export from Money as QIF format instead.'
  };
}

function readString(uint8Array: Uint8Array, offset: number, maxLength: number): string {
  let str = '';
  for (let i = 0; i < maxLength && offset + i < uint8Array.length; i++) {
    const byte = uint8Array[offset + i];
    if (byte === 0) break;
    if (byte >= 32 && byte <= 126) {
      str += String.fromCharCode(byte);
    }
  }
  return str.trim();
}

function readUTF16String(uint8Array: Uint8Array, offset: number, maxLength: number): string {
  let str = '';
  for (let i = 0; i < maxLength && offset + i * 2 + 1 < uint8Array.length; i++) {
    const charCode = uint8Array[offset + i * 2] | (uint8Array[offset + i * 2 + 1] << 8);
    if (charCode === 0) break;
    if (charCode >= 32 && charCode < 65536) {
      str += String.fromCharCode(charCode);
    }
  }
  return str.trim();
}

export function applyMappingToData(rawData: any[], mapping: any): { accounts: ParsedAccount[], transactions: ParsedTransaction[] } {
  const accounts = new Map<string, ParsedAccount>();
  const transactions: ParsedTransaction[] = [];
  
  // Process each record using the mapping
  rawData.forEach(record => {
    try {
      // Get mapped values
      const dateField = record[Object.keys(record)[mapping.date]];
      const amountField = record[Object.keys(record)[mapping.amount]];
      const descField = record[Object.keys(record)[mapping.description]];
      
      // Convert date
      let date: Date;
      if (typeof dateField === 'number' && dateField > 30000 && dateField < 60000) {
        // OLE date
        date = new Date((dateField - 25569) * 86400 * 1000);
      } else if (dateField instanceof Date) {
        date = dateField;
      } else {
        date = new Date(dateField);
      }
      
      if (isNaN(date.getTime())) return;
      
      // Get amount
      const amount = parseFloat(String(amountField));
      if (isNaN(amount)) return;
      
      // Get optional fields
      const payee = mapping.payee !== undefined ? record[Object.keys(record)[mapping.payee]] : undefined;
      const category = mapping.category !== undefined ? record[Object.keys(record)[mapping.category]] : 'Imported';
      const accountName = mapping.accountName !== undefined ? record[Object.keys(record)[mapping.accountName]] : 'Primary Account';
      
      // Add account if new
      if (accountName && !accounts.has(accountName)) {
        accounts.set(accountName, {
          name: accountName,
          type: 'checking',
          balance: 0
        });
      }
      
      // Create transaction
      transactions.push({
        date,
        amount: Math.abs(amount),
        description: String(descField),
        type: amount < 0 ? 'expense' : 'income',
        category: String(category),
        payee: payee ? String(payee) : undefined,
        accountName
      });
      
    } catch (error) {
      console.error('Error processing record:', error);
    }
  });
  
  // Calculate balances
  accounts.forEach(account => {
    const accountTrans = transactions.filter(t => t.accountName === account.name);
    const income = accountTrans.filter(t => t.type === 'income').reduce((sum, t) => sum + t.amount, 0);
    const expenses = accountTrans.filter(t => t.type === 'expense').reduce((sum, t) => sum + t.amount, 0);
    account.balance = income - expenses;
  });
  
  return {
    accounts: Array.from(accounts.values()),
    transactions
  };
}

export async function parseMBF(arrayBuffer: ArrayBuffer): Promise<ParseResult> {
  const uint8Array = new Uint8Array(arrayBuffer);
  const dataView = new DataView(arrayBuffer);
  
  console.log('Parsing Microsoft Money .mbf backup file, size:', arrayBuffer.byteLength);
  
  // Check file header to understand format
  const header = Array.from(uint8Array.slice(0, 64))
    .map(b => b.toString(16).padStart(2, '0'))
    .join(' ');
  console.log('MBF file header:', header);
  
  // Check if file appears to be compressed or encrypted
  let textFound = 0;
  for (let i = 0; i < Math.min(10000, arrayBuffer.byteLength); i++) {
    const byte = uint8Array[i];
    if (byte >= 32 && byte <= 126) {
      textFound++;
    }
  }
  
  const textPercentage = (textFound / Math.min(10000, arrayBuffer.byteLength)) * 100;
  console.log(`Readable text percentage in first 10KB: ${textPercentage.toFixed(1)}%`);
  
  // Try to extract structured data
  const potentialRecords: any[] = [];
  
  // MBF files might have different structure than MNY
  // Let's try multiple approaches
  
  // Approach 1: Look for record boundaries
  const recordSizes = [128, 256, 512, 1024]; // Common record sizes
  
  for (const recordSize of recordSizes) {
    console.log(`Trying record size: ${recordSize} bytes`);
    const testRecords: any[] = [];
    
    for (let offset = 0; offset < Math.min(50000, arrayBuffer.byteLength) && testRecords.length < 100; offset += recordSize) {
      const record: any = {};
      let hasData = false;
      
      // Try to extract different data types
      for (let i = 0; i < Math.min(20, recordSize / 8); i++) {
        const pos = offset + i * 8;
        
        if (pos + 8 <= arrayBuffer.byteLength) {
          // Try as double
          const doubleValue = dataView.getFloat64(pos, true);
          
          // OLE date check
          if (doubleValue > 30000 && doubleValue < 60000) {
            record[`field_${i}_date`] = doubleValue;
            hasData = true;
          }
          // Currency amount check
          else if (Math.abs(doubleValue) > 0.01 && Math.abs(doubleValue) < 1000000) {
            record[`field_${i}_amount`] = doubleValue;
            hasData = true;
          }
          
          // Try as 32-bit values
          if (pos + 4 <= arrayBuffer.byteLength) {
            const int32 = dataView.getInt32(pos, true);
            const float32 = dataView.getFloat32(pos, true);
            
            // Check for reasonable values
            if (int32 > 0 && int32 < 1000000) {
              record[`field_${i}_int32`] = int32;
            }
            if (Math.abs(float32) > 0.01 && Math.abs(float32) < 10000) {
              record[`field_${i}_float32`] = float32;
            }
          }
        }
        
        // Try to read strings at various positions
        const strPos = offset + i * 16;
        if (strPos < arrayBuffer.byteLength - 50) {
          const ascii = readString(uint8Array, strPos, 50);
          const utf16 = readUTF16String(uint8Array, strPos, 25);
          
          if (ascii && ascii.length > 2 && ascii.length < 50) {
            record[`field_${i}_text`] = ascii;
            hasData = true;
          }
          if (utf16 && utf16.length > 2 && utf16.length < 50 && utf16 !== ascii) {
            record[`field_${i}_text_utf16`] = utf16;
            hasData = true;
          }
        }
      }
      
      if (hasData && Object.keys(record).length >= 2) {
        testRecords.push(record);
      }
    }
    
    // If this record size found good data, use it
    if (testRecords.length > 10) {
      console.log(`Found ${testRecords.length} records with size ${recordSize}`);
      potentialRecords.push(...testRecords);
      break;
    }
  }
  
  // Approach 2: Look for specific MBF patterns
  if (potentialRecords.length < 10) {
    console.log('Trying pattern-based extraction...');
    
    // MBF might use different date encoding
    for (let i = 0; i < Math.min(arrayBuffer.byteLength - 100, 100000); i++) {
      const record: any = {};
      let foundDate = false;
      let foundAmount = false;
      
      // Check for various date formats
      // Format 1: Days since 1900 (32-bit)
      if (i + 4 <= arrayBuffer.byteLength) {
        const days = dataView.getInt32(i, true);
        if (days > 25000 && days < 50000) {
          const date = new Date(1900, 0, 1);
          date.setDate(date.getDate() + days);
          if (date.getFullYear() >= 1990 && date.getFullYear() <= 2030) {
            record.date_value = days;
            record.date_formatted = date.toLocaleDateString();
            foundDate = true;
          }
        }
      }
      
      if (foundDate) {
        // Look for amount nearby
        for (let j = 4; j < 50; j += 4) {
          if (i + j + 8 > arrayBuffer.byteLength) break;
          
          const amount64 = dataView.getFloat64(i + j, true);
          const amount32 = dataView.getFloat32(i + j, true);
          const amountInt = dataView.getInt32(i + j, true);
          
          if (Math.abs(amount64) > 0.01 && Math.abs(amount64) < 100000) {
            record.amount = amount64;
            foundAmount = true;
            break;
          } else if (Math.abs(amount32) > 0.01 && Math.abs(amount32) < 100000) {
            record.amount = amount32;
            foundAmount = true;
            break;
          } else if (Math.abs(amountInt / 100) > 0.01 && Math.abs(amountInt / 100) < 100000) {
            record.amount = amountInt / 100; // Cents to dollars
            foundAmount = true;
            break;
          }
        }
      }
      
      if (foundDate && foundAmount) {
        // Look for description
        for (let k = 0; k < 200; k += 10) {
          const desc = readString(uint8Array, i + k, 100) || readUTF16String(uint8Array, i + k, 50);
          if (desc && desc.length > 2 && desc.length < 100) {
            record.description = desc;
            break;
          }
        }
        
        if (Object.keys(record).length >= 3) {
          potentialRecords.push(record);
          i += 50; // Skip ahead
        }
      }
    }
  }
  
  console.log(`Extracted ${potentialRecords.length} potential records from MBF file`);
  
  if (potentialRecords.length > 10) {
    return {
      accounts: [],
      transactions: [],
      rawData: potentialRecords,
      needsMapping: true,
      warning: 'Found data in your Money backup file. Please help us map the fields correctly.'
    };
  }
  
  // If we couldn't extract meaningful data
  return {
    accounts: [{
      name: 'Money Backup File',
      type: 'checking',
      balance: 0
    }],
    transactions: [],
    warning: 'Unable to extract data from this Money backup file. The file may be encrypted or in a format we don\'t support. Please try exporting as QIF from Microsoft Money instead.'
  };
}


=== src/utils/qifParser.ts ===
// QIF file parser optimized for Microsoft Money exports

export interface ParsedAccount {
  name: string;
  type: 'checking' | 'savings' | 'credit' | 'loan' | 'investment';
  balance: number;
}

export interface ParsedTransaction {
  date: Date;
  amount: number;
  description: string;
  type: 'income' | 'expense';
  category: string;
  payee?: string;
  accountName?: string;
}

export interface ParsedData {
  accounts: ParsedAccount[];
  transactions: ParsedTransaction[];
}

export function parseQIF(content: string): ParsedData {
  const lines = content.split(/\r?\n/);
  const transactions: ParsedTransaction[] = [];
  const accountsMap = new Map<string, ParsedAccount>();
  
  let currentTransaction: any = {};
  let currentAccountName = '';
  let currentAccountType = 'checking';
  
  console.log('Enhanced QIF parsing - looking for multiple accounts');
  
  // First pass - look for explicit account definitions
  let i = 0;
  while (i < lines.length) {
    const line = lines[i].trim();
    
    if (line === '!Account') {
      // Found account section
      let accountName = '';
      let accountType: ParsedAccount['type'] = 'checking';
      let balance = 0;
      
      i++;
      while (i < lines.length && !lines[i].startsWith('!')) {
        const accountLine = lines[i].trim();
        
        if (accountLine.startsWith('N')) {
          accountName = accountLine.substring(1).trim();
        } else if (accountLine.startsWith('T')) {
          const typeStr = accountLine.substring(1).toLowerCase();
          if (typeStr.includes('credit') || typeStr === 'ccard') {
            accountType = 'credit';
          } else if (typeStr.includes('savings') || typeStr.includes('oth a')) {
            accountType = 'savings';
          } else if (typeStr.includes('invest')) {
            accountType = 'investment';
          } else if (typeStr.includes('loan') || typeStr.includes('mort')) {
            accountType = 'loan';
          }
        } else if (accountLine.startsWith('B')) {
          // Balance
          const balanceStr = accountLine.substring(1).replace(/[,£$]/g, '');
          balance = parseFloat(balanceStr) || 0;
        } else if (accountLine.startsWith('^')) {
          // End of account record
          break;
        }
        i++;
      }
      
      if (accountName) {
        accountsMap.set(accountName, {
          name: accountName,
          type: accountType,
          balance: balance
        });
        console.log('Found account:', accountName, 'Type:', accountType);
      }
    } else if (line.startsWith('!Type:')) {
      // This might indicate the account type for following transactions
      currentAccountName = currentAccountName || 'Default Account';
      
      const typeStr = line.substring(6).toLowerCase();
      if (typeStr.includes('bank')) {
        currentAccountType = 'checking';
      } else if (typeStr.includes('cash')) {
        currentAccountType = 'checking';
      } else if (typeStr.includes('ccard') || typeStr.includes('credit')) {
        currentAccountType = 'credit';
      } else if (typeStr.includes('invst')) {
        currentAccountType = 'investment';
      } else if (typeStr.includes('oth l')) {
        currentAccountType = 'loan';
      } else if (typeStr.includes('oth a')) {
        currentAccountType = 'savings';
      }
    }
    
    i++;
  }
  
  // Second pass - parse transactions and detect accounts from category patterns
  i = 0;
  let transactionCount = 0;
  const accountBalances = new Map<string, { income: number; expenses: number }>();
  
  while (i < lines.length) {
    const line = lines[i].trim();
    
    if (line.startsWith('^')) {
      // End of transaction
      if (currentTransaction.date && currentTransaction.amount !== undefined) {
        // Try to detect account from category
        let accountName = currentAccountName || 'General Account';
        
        // Look for account indicators in category
        if (currentTransaction.category) {
          // Check for [AccountName] pattern
          const bracketMatch = currentTransaction.category.match(/\[([^\]]+)\]/);
          if (bracketMatch) {
            accountName = bracketMatch[1];
            currentTransaction.category = currentTransaction.category.replace(/\[([^\]]+)\]/, '').trim();
          }
          
          // Check for "AccountName:" pattern
          const colonMatch = currentTransaction.category.match(/^([^:]+):/);
          if (colonMatch && colonMatch[1].length < 50) {
            accountName = colonMatch[1];
            currentTransaction.category = currentTransaction.category.substring(colonMatch[0].length).trim();
          }
        }
        
        // Check for account transfers (common pattern: "Transfer from/to AccountName")
        if (currentTransaction.payee) {
          const transferMatch = currentTransaction.payee.match(/Transfer (?:from|to) (.+)/i);
          if (transferMatch) {
            const otherAccount = transferMatch[1];
            if (!accountsMap.has(otherAccount)) {
              accountsMap.set(otherAccount, {
                name: otherAccount,
                type: 'checking',
                balance: 0
              });
            }
          }
        }
        
        // Add the primary account if not exists
        if (!accountsMap.has(accountName)) {
          accountsMap.set(accountName, {
            name: accountName,
            type: currentAccountType as ParsedAccount['type'],
            balance: 0
          });
        }
        
        // Track balances
        if (!accountBalances.has(accountName)) {
          accountBalances.set(accountName, { income: 0, expenses: 0 });
        }
        
        const balances = accountBalances.get(accountName)!;
        if (currentTransaction.amount > 0) {
          balances.income += Math.abs(currentTransaction.amount);
        } else {
          balances.expenses += Math.abs(currentTransaction.amount);
        }
        
        const transaction: ParsedTransaction = {
          date: currentTransaction.date,
          amount: Math.abs(currentTransaction.amount),
          description: currentTransaction.payee || currentTransaction.memo || 'No description',
          type: currentTransaction.amount < 0 ? 'expense' : 'income',
          category: currentTransaction.category || 'Uncategorized',
          payee: currentTransaction.payee,
          accountName: accountName
        };
        
        transactions.push(transaction);
        transactionCount++;
        
        if (transactionCount % 100 === 0) {
          console.log(`Processed ${transactionCount} transactions...`);
        }
      }
      currentTransaction = {};
    } else if (line.startsWith('D')) {
      // Date
      const dateStr = line.substring(1).trim();
      currentTransaction.date = parseQIFDate(dateStr);
    } else if (line.startsWith('T')) {
      // Amount
      const amountStr = line.substring(1).replace(/[,£$]/g, '').trim();
      currentTransaction.amount = parseFloat(amountStr);
    } else if (line.startsWith('P')) {
      // Payee
      currentTransaction.payee = line.substring(1).trim();
    } else if (line.startsWith('M')) {
      // Memo
      currentTransaction.memo = line.substring(1).trim();
    } else if (line.startsWith('L')) {
      // Category
      currentTransaction.category = line.substring(1).trim();
    } else if (line.startsWith('N')) {
      // Number/Check number
      if (!line.startsWith('N0') && line.length > 2) {
        currentTransaction.checkNum = line.substring(1).trim();
      }
    }
    
    i++;
  }
  
  // Calculate final balances
  accountBalances.forEach((balances, accountName) => {
    const account = accountsMap.get(accountName);
    if (account) {
      account.balance = balances.income - balances.expenses;
    }
  });
  
  // If we only found one generic account but have many transactions, 
  // try to extract more accounts from transaction patterns
  if (accountsMap.size <= 1 && transactions.length > 10) {
    console.log('Only one account found, analyzing transactions for more accounts...');
    
    // Look for patterns in payees that might indicate accounts
    transactions.forEach(t => {
      // Credit card patterns
      if (t.payee && t.payee.match(/VISA|MASTERCARD|AMEX|DISCOVER/i)) {
        const cardMatch = t.payee.match(/(VISA|MASTERCARD|AMEX|DISCOVER).*?(\d{4})/i);
        if (cardMatch) {
          const cardName = `${cardMatch[1]} ...${cardMatch[2]}`;
          if (!accountsMap.has(cardName)) {
            accountsMap.set(cardName, {
              name: cardName,
              type: 'credit',
              balance: 0
            });
          }
        }
      }
      
      // Bank account patterns (like "HSBC 1234")
      if (t.payee && t.payee.match(/HSBC|BARCLAYS|LLOYDS|NATWEST|SANTANDER/i)) {
        const bankMatch = t.payee.match(/(HSBC|BARCLAYS|LLOYDS|NATWEST|SANTANDER).*?(\d{4})/i);
        if (bankMatch) {
          const accountName = `${bankMatch[1]} ...${bankMatch[2]}`;
          if (!accountsMap.has(accountName)) {
            accountsMap.set(accountName, {
              name: accountName,
              type: 'checking',
              balance: 0
            });
          }
        }
      }
    });
  }
  
  // Ensure we have at least one account
  if (accountsMap.size === 0) {
    accountsMap.set('Imported Account', {
      name: 'Imported Account',
      type: 'checking',
      balance: 0
    });
  }
  
  console.log(`Final result: ${accountsMap.size} accounts and ${transactions.length} transactions`);
  
  return {
    accounts: Array.from(accountsMap.values()),
    transactions: transactions
  };
}

function parseQIFDate(dateStr: string): Date {
  // Try different date formats
  let date: Date | null = null;
  
  // Format: MM/DD/YY or MM/DD/YYYY
  const slashParts = dateStr.split('/');
  if (slashParts.length === 3) {
    const month = parseInt(slashParts[0]);
    const day = parseInt(slashParts[1]);
    let year = parseInt(slashParts[2]);
    if (year < 100) {
      year = year < 50 ? 2000 + year : 1900 + year;
    }
    date = new Date(year, month - 1, day);
  }
  
  // Format: MM-DD-YY or MM-DD-YYYY
  if (!date || isNaN(date.getTime())) {
    const dashParts = dateStr.split('-');
    if (dashParts.length === 3) {
      const month = parseInt(dashParts[0]);
      const day = parseInt(dashParts[1]);
      let year = parseInt(dashParts[2]);
      if (year < 100) {
        year = year < 50 ? 2000 + year : 1900 + year;
      }
      date = new Date(year, month - 1, day);
    }
  }
  
  // Format: DD/MM/YYYY (UK format)
  if (!date || isNaN(date.getTime())) {
    const ukParts = dateStr.split('/');
    if (ukParts.length === 3) {
      const day = parseInt(ukParts[0]);
      const month = parseInt(ukParts[1]);
      const year = parseInt(ukParts[2]);
      if (day <= 31 && month <= 12) {
        date = new Date(year, month - 1, day);
      }
    }
  }
  
  // Format: YYYY-MM-DD (ISO format)
  if (!date || isNaN(date.getTime())) {
    const isoParts = dateStr.split('-');
    if (isoParts.length === 3 && isoParts[0].length === 4) {
      const year = parseInt(isoParts[0]);
      const month = parseInt(isoParts[1]);
      const day = parseInt(isoParts[2]);
      date = new Date(year, month - 1, day);
    }
  }
  
  return date || new Date();
}


=== src/vite-env.d.ts ===
/// <reference types="vite/client" />
